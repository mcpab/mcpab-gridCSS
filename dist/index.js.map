{"version":3,"sources":["../src/box/boxPositions.ts","../src/geometry/matrixAlgebra.ts","../src/geometry/coordinateAlgebra.ts","../src/geometry/coordinateMetrics.ts","../src/geometry/coordinatesUtils.ts","../src/box/gridBoxUtils.ts","../src/boxTransformations/defaultBoxTransformations.ts","../src/boxTransformations/boxTransformationsProps.ts","../src/boxDesign/transformBoxMove.ts","../src/boxDesign/layoutSectionBtoAbsolute.ts","../src/boxDesign/layoutSectionToBounds.ts","../src/boxDesign/layoutTxToSectionLocal.ts","../src/boxDesign/CSSlayout.ts","../src/layoutTheme/defaultLayoutTheme.ts","../src/boxDesign/layoutToTx.ts","../src/templates/layoutsCatalog.ts","../src/utils/utils.ts"],"sourcesContent":["/**\n * @fileoverview Box position utilities for grid layout system.\n * Provides functions to calculate specific anchor points within boxes.\n * @module BoxPositions\n */\n\nimport { Coordinate } from \"../geometry\";\nimport { GridBoxPointPosition } from \"./gridBoxTypes\";\n\n\n/**\n * Calculates the coordinate position of a specific anchor point within a box.\n * \n * @param box - The grid box object containing origin and diagonal properties\n * @param boxAnchor - The anchor position to calculate: 'bottomLeft' | 'bottomRight' | 'topLeft' | 'topRight' | 'center'\n * @returns The coordinate of the specified anchor point, or undefined if anchor is invalid\n * \n * @example\n * ```typescript\n * // 'bottomLeft' | 'bottomRight' | 'topLeft' | 'topRight' | 'center'\n * const box = { origin: { x: 0, y: 0 }, diagonal: { x: 100, y: 50 } };\n * const centerPos = boxPosition(box, 'center');\n * ```\n */\nexport const boxPosition: GridBoxPointPosition = (box, boxAnchor) => {\n\n    let coordinate: Coordinate;\n\n    // Calculate coordinate based on the anchor position\n    if (boxAnchor === 'bottomLeft') {\n        // Bottom-left is the box origin\n        coordinate = {\n            x: box.origin.x,\n            y: box.origin.y\n        };\n    } else if (boxAnchor === 'bottomRight') {\n        // Bottom-right adds full width to origin x\n        coordinate = {\n            x: box.origin.x + box.diagonal.x,\n            y: box.origin.y\n        };\n    } else if (boxAnchor === 'topLeft') {\n        // Top-left adds full height to origin y\n        coordinate = {\n            x: box.origin.x,\n            y: box.origin.y + box.diagonal.y\n        };\n    } else if (boxAnchor === 'topRight') {\n        // Top-right adds both width and height to origin\n        coordinate = {\n            x: box.origin.x + box.diagonal.x,\n            y: box.origin.y + box.diagonal.y\n        };\n    } else if (boxAnchor === 'center') {\n        // Center point is origin plus half width and half height\n        coordinate = {\n            x: box.origin.x + box.diagonal.x / 2,\n            y: box.origin.y + box.diagonal.y / 2\n        };\n    } else {\n        // Return undefined for invalid anchor positions\n        return undefined;\n    }\n\n    return coordinate;\n\n}\n\n/**\n * Moves a box so that its specified anchor point is positioned at the given coordinate.\n * \n * @param box - The grid box to move\n * @param boxAnchor - The anchor point of the box to align with the target coordinate\n * @param coordinate - The target coordinate or a function that calculates it\n * @returns A new box with updated position, or undefined if operation fails\n * \n * @example\n * ```typescript\n * export const moveTo: MoveBoxTo = (box, boxAnchor, coordinate) => {\n *     let anchor = boxPosition(box, boxAnchor);\n *     if (!anchor) return undefined;\n *     let target: Coordinate;\n *     if (typeof coordinate === 'function') {\n *         let result = coordinate(box, boxAnchor);\n *         if (!result) return undefined;\n *         target = result;\n *     } else {\n *         target = coordinate;\n *     }\n *     const delta = subtractCoordinates(target, anchor);\n *     const newOrigin = addCoordinates(box.origin, delta);\n *     return {\n *         ...box,\n *         origin: newOrigin\n *     };\n * }\n * ```\n */\n// export const moveTo: MoveBoxTo = (box, boxAnchor, coordinate) => {\n\n//     let anchor = boxPosition(box, boxAnchor);\n//     if (!anchor) return undefined;\n\n//     let target: Coordinate;\n\n//     if (typeof coordinate === 'function') {\n//         let result = coordinate(box, boxAnchor);\n//         if (!result) return undefined;\n//         target = result;\n//         //\n//     } else {\n//         target = coordinate;\n//     }\n\n//     const delta = subtractCoordinates(target, anchor);\n\n//     const newOrigin = addCoordinates(box.origin, delta);\n\n//     return {\n//         ...box,\n//         origin: newOrigin\n//     };\n// }\n\n/**\n * Moves a box by a specified delta from its current anchor position.\n * \n * @param box - The grid box to move\n * @param boxAnchor - The anchor point to use as reference for the movement\n * @param delta - The movement delta or a function that calculates it\n * @returns A new box with updated position, or undefined if operation fails\n * \n * @example\n * ```typescript\n * export const moveBy: MoveBoxBy = (box, boxAnchor, delta) => {\n *     let anchor = boxPosition(box, boxAnchor);\n *     if (!anchor) return undefined;\n *     let movement: Coordinate;\n *     if (typeof delta === 'function') {\n *         let result = delta(box, boxAnchor);\n *         if (!result) return undefined;\n *         movement = result;\n *     } else {\n *         movement = delta;\n *     }\n *     const newOrigin = addCoordinates(box.origin, movement);\n *     return {\n *         ...box,\n *         origin: newOrigin\n *     };\n * }\n * ```\n */\n// export const moveBy: MoveBoxBy = (box, boxAnchor, delta) => {\n\n//     let anchor = boxPosition(box, boxAnchor);\n//     if (!anchor) return undefined;\n\n//     let movement: Coordinate;\n\n//     if (typeof delta === 'function') {\n//         let result = delta(box, boxAnchor);\n//         if (!result) return undefined;\n//         movement = result;\n//         //\n//     } else {\n//         movement = delta;\n//     }\n\n//     const newOrigin = addCoordinates(box.origin, movement);\n\n//     return {\n//         ...box,\n//         origin: newOrigin\n//     };\n\n// }\n\n/**\n * Stretches a box by adding the specified delta to both width and height.\n * \n * The delta is applied as an absolute value to ensure the box always grows.\n * \n * @param box - The grid box to stretch\n * @param delta - The amount to add to both width and height (will be made absolute)\n * @returns A new box with increased dimensions\n * \n * @example\n * ```typescript\n * export const stretch: StretchBox = (box, delta) => {\n *     return {\n *         ...box,\n *         diagonal: {\n *             x: box.diagonal.x + Math.abs(delta),\n *             y: box.diagonal.y + Math.abs(delta)\n *         }\n *     };\n * }\n * ```\n */\n// export const stretch: StretchBox = (box, delta) => {\n//     return {\n//         ...box,\n//         diagonal: {\n//             x: box.diagonal.x + Math.abs(delta),\n//             y: box.diagonal.y + Math.abs(delta)\n//         }\n//     };\n// }","/**\n * @fileoverview 2x2 matrix algebra operations for geometric transformations.\n * Provides matrix constants and operations for coordinate transformations in 2D space.\n * @module MatrixAlgebra\n */\n\nimport { Coordinate } from \"./coordinateTypes\";\nimport { Matrix2x2, UnitMatrix } from \"./matrixTypes\";\n\n/**\n * The 2x2 identity matrix.\n * Leaves coordinates unchanged when multiplied.\n * \n * @example\n * ```typescript\n * // Identity matrix: [[1, 0], [0, 1]]\n * const point: Coordinate = { x: 5, y: 3 };\n * const unchanged = multiply(unitMatrix, point);  // { x: 5, y: 3 }\n * \n * // Useful as starting point for transformations\n * const customMatrix = unitMatrix.map(row => [...row]);\n * ```\n */\nexport const unitMatrix: UnitMatrix<1> = [[1, 0],\n[0, 1]];\n\n/**\n * The 2x2 zero matrix.\n * Maps all coordinates to the origin (0, 0).\n * \n * @example\n * ```typescript\n * // Zero matrix: [[0, 0], [0, 0]]\n * const point: Coordinate = { x: 10, y: 20 };\n * const origin = multiply(zeroMatrix, point);  // { x: 0, y: 0 }\n * \n * // Useful for nullifying transformations\n * ```\n */\nexport const zeroMatrix: UnitMatrix<0> = [[0, 0],\n[0, 0]];\n\n/**\n * Reflection matrix across the X-axis.\n * Negates the y-coordinate while preserving the x-coordinate.\n * \n * @example\n * ```typescript\n * // Reflection on X-axis: [[1, 0], [0, -1]]\n * const point: Coordinate = { x: 5, y: 3 };\n * const reflected = multiply(reflectionOnXAxis, point);  // { x: 5, y: -3 }\n * \n * // Mirror points across horizontal axis\n * const upperPoint = { x: 2, y: 4 };\n * const lowerPoint = multiply(reflectionOnXAxis, upperPoint);  // { x: 2, y: -4 }\n * ```\n */\nexport const reflectionOnXAxis: Matrix2x2 = [[1, 0],\n[0, -1]];\n\n/**\n * Reflection matrix across the Y-axis.\n * Negates the x-coordinate while preserving the y-coordinate.\n * \n * @example\n * ```typescript\n * // Reflection on Y-axis: [[-1, 0], [0, 1]]\n * const point: Coordinate = { x: 5, y: 3 };\n * const reflected = multiply(reflectionOnYAxis, point);  // { x: -5, y: 3 }\n * \n * // Mirror points across vertical axis\n * const rightPoint = { x: 7, y: 2 };\n * const leftPoint = multiply(reflectionOnYAxis, rightPoint);  // { x: -7, y: 2 }\n * ```\n */\nexport const reflectionOnYAxis: Matrix2x2 = [[-1, 0],\n[0, 1]];\n\n/**\n * Creates a 2x2 rotation matrix for clockwise rotation by the specified angle.\n * Uses standard rotation matrix formula with trigonometric functions.\n * \n * @param theta - The rotation angle in radians (positive for clockwise rotation)\n * @returns 2x2 rotation matrix\n * \n * @example\n * ```typescript\n * // 90-degree clockwise rotation\n * const rotate90 = rotationByThetaClockWise(Math.PI / 2);\n * const point = { x: 1, y: 0 };\n * const rotated = multiply(rotate90, point);  // { x: 0, y: -1 }\n * \n * // 45-degree rotation\n * const rotate45 = rotationByThetaClockWise(Math.PI / 4);\n * const diagonal = multiply(rotate45, { x: 1, y: 1 });\n * // Result: approximately { x: 1.414, y: 0 }\n * \n * // 180-degree rotation (equivalent to point inversion)\n * const rotate180 = rotationByThetaClockWise(Math.PI);\n * const inverted = multiply(rotate180, { x: 3, y: 4 });  // { x: -3, y: -4 }\n * \n * // Convert degrees to radians\n * const rotateByDegrees = (degrees: number) => \n *   rotationByThetaClockWise(degrees * Math.PI / 180);\n * ```\n */\nexport const rotationByThetaClockWise = (theta: number): Matrix2x2 => {\n    const cosTheta = Math.cos(theta);\n    const sinTheta = Math.sin(theta);\n    return [\n        [cosTheta, sinTheta],\n        [-sinTheta, cosTheta]\n    ];\n};\n\n/**\n * Multiplies a 2x2 matrix by a coordinate vector.\n * Performs matrix-vector multiplication: M * v where M is 2x2 and v is 2x1.\n * \n * @param matrix - The 2x2 transformation matrix\n * @param v - The coordinate vector to transform\n * @returns The transformed coordinate\n * \n * @example\n * ```typescript\n * // Basic matrix multiplication\n * const matrix: Matrix2x2 = [[2, 0], [0, 3]];\n * const point: Coordinate = { x: 4, y: 5 };\n * const result = multiply(matrix, point);  // { x: 8, y: 15 }\n * \n * // Chain transformations\n * const scale2x = [[2, 0], [0, 2]];\n * const rotate90 = rotationByThetaClockWise(Math.PI / 2);\n * \n * const original = { x: 1, y: 1 };\n * const scaled = multiply(scale2x, original);     // { x: 2, y: 2 }\n * const rotated = multiply(rotate90, scaled);     // { x: 2, y: -2 }\n * \n * // Identity transformation\n * const unchanged = multiply(unitMatrix, point);  // { x: 4, y: 5 }\n * \n * // Formula: [a b] * [x] = [ax + by]\n * //          [c d]   [y]   [cx + dy]\n * ```\n */\nexport const multiply = (matrix: Matrix2x2, v:Coordinate): Coordinate => {\n    return {\n        x: matrix[0][0] * v.x + matrix[0][1] * v.y,\n        y: matrix[1][0] * v.x + matrix[1][1] * v.y,\n    };\n}\n\n\n","/**\n * @fileoverview Coordinate algebra operations for 2D vector mathematics.\n * Provides essential mathematical operations for coordinate manipulation and transformations.\n * @module CoordinateAlgebra\n */\n\nimport { Coordinate } from \"./coordinateTypes\"\nimport { multiply, reflectionOnXAxis, reflectionOnYAxis, rotationByThetaClockWise } from \"./matrixAlgebra\";\n\n/**\n * Returns the origin coordinate (0, 0).\n * Convenient factory function for creating the zero vector.\n * \n * @returns The origin coordinate { x: 0, y: 0 }\n * \n * @example\n * ```typescript\n * const origin = getOrigin();  // { x: 0, y: 0 }\n * \n * // Use as starting point for calculations\n * const offset = addCoordinates(origin, { x: 10, y: 20 });\n * ```\n */\nexport const getOrigin = (): Coordinate => {\n    return { x: 0, y: 0 };\n}\n\n/**\n * Calculates a linear combination of two coordinates.\n * Computes alpha * a + beta * b for two coordinates with scalar coefficients.\n * \n * @param alpha - Scalar coefficient for coordinate a\n * @param a - First coordinate\n * @param beta - Scalar coefficient for coordinate b  \n * @param b - Second coordinate\n * @returns The linear combination result\n * \n * @example\n * ```typescript\n * const a: Coordinate = { x: 2, y: 3 };\n * const b: Coordinate = { x: 4, y: 1 };\n * \n * // 2 * a + 3 * b = 2*(2,3) + 3*(4,1) = (4,6) + (12,3) = (16,9)\n * const result = linearCombination(2, a, 3, b);  // { x: 16, y: 9 }\n * \n * // Weighted average: 0.7 * a + 0.3 * b\n * const blend = linearCombination(0.7, a, 0.3, b);\n * ```\n */\nexport const linearCombination = (alpha: number, a: Coordinate, beta: number, b: Coordinate): Coordinate => {\n    return { x: a.x * alpha + b.x * beta, y: a.y * alpha + b.y * beta };\n}\n\n/**\n * Multiplies a coordinate by a scalar value.\n * Scales both x and y components by the same factor.\n * \n * @param scalar - The scaling factor\n * @param a - The coordinate to scale\n * @returns The scaled coordinate\n * \n * @example\n * ```typescript\n * const coord: Coordinate = { x: 3, y: 4 };\n * \n * const doubled = multiplyScalar(2, coord);     // { x: 6, y: 8 }\n * const halved = multiplyScalar(0.5, coord);    // { x: 1.5, y: 2 }\n * const negated = multiplyScalar(-1, coord);    // { x: -3, y: -4 }\n * ```\n */\nexport const multiplyScalar = (scalar: number, a: Coordinate): Coordinate => {\n    return linearCombination(scalar, a, 0, getOrigin());\n}\n\n/**\n * Adds two coordinates together (vector addition).\n * Combines the x and y components separately.\n * \n * @param a - First coordinate\n * @param b - Second coordinate  \n * @returns The sum of the coordinates\n * \n * @example\n * ```typescript\n * const pointA: Coordinate = { x: 2, y: 3 };\n * const offset: Coordinate = { x: 5, y: -1 };\n * \n * const result = addCoordinates(pointA, offset);  // { x: 7, y: 2 }\n * \n * // Chain multiple additions\n * const final = addCoordinates(\n *   addCoordinates(pointA, offset),\n *   { x: 1, y: 1 }\n * );  // { x: 8, y: 3 }\n * ```\n */\nexport const addCoordinates = (a: Coordinate, b: Coordinate): Coordinate => {\n    return linearCombination(1, a, 1, b);\n}\n\n/**\n * Subtracts the second coordinate from the first (vector subtraction).\n * Computes a - b by subtracting corresponding components.\n * \n * @param a - The coordinate to subtract from\n * @param b - The coordinate to subtract\n * @returns The difference a - b\n * \n * @example\n * ```typescript\n * const endPoint: Coordinate = { x: 10, y: 8 };\n * const startPoint: Coordinate = { x: 3, y: 2 };\n * \n * const displacement = subtractCoordinates(endPoint, startPoint);  // { x: 7, y: 6 }\n * \n * // Calculate distance vector\n * const from: Coordinate = { x: 1, y: 1 };\n * const to: Coordinate = { x: 4, y: 5 };\n * const vector = subtractCoordinates(to, from);  // { x: 3, y: 4 }\n * ```\n */\nexport const subtractCoordinates = (a: Coordinate, b: Coordinate): Coordinate => {\n    return linearCombination(1, a, -1, b);\n}\n\n/**\n * Reflects a coordinate across the X-axis.\n * Negates the y-component while keeping x unchanged.\n * \n * @param coord - The coordinate to reflect\n * @returns The reflected coordinate\n * \n * @example\n * ```typescript\n * const point: Coordinate = { x: 3, y: 4 };\n * const reflected = reflectOnXAxis(point);  // { x: 3, y: -4 }\n * \n * // Mirror across horizontal axis\n * const upperPoint: Coordinate = { x: 2, y: 5 };\n * const lowerPoint = reflectOnXAxis(upperPoint);  // { x: 2, y: -5 }\n * ```\n */\nexport const reflectOnXAxis = (coord: Coordinate): Coordinate => {\n    return multiply(reflectionOnXAxis, coord);\n}\n\n/**\n * Reflects a coordinate across the Y-axis.\n * Negates the x-component while keeping y unchanged.\n * \n * @param coord - The coordinate to reflect\n * @returns The reflected coordinate\n * \n * @example\n * ```typescript\n * const point: Coordinate = { x: 3, y: 4 };\n * const reflected = reflectOnYAxis(point);  // { x: -3, y: 4 }\n * \n * // Mirror across vertical axis\n * const rightPoint: Coordinate = { x: 5, y: 2 };\n * const leftPoint = reflectOnYAxis(rightPoint);  // { x: -5, y: 2 }\n * ```\n */\nexport const reflectOnYAxis = (coord: Coordinate): Coordinate => {\n    return multiply(reflectionOnYAxis, coord);\n}\n\n/**\n * Rotates a coordinate clockwise by the specified angle.\n * Uses matrix multiplication for accurate rotation transformation.\n * \n * @param theta - The rotation angle in radians (clockwise)\n * @param coord - The coordinate to rotate\n * @returns The rotated coordinate\n * \n * @example\n * ```typescript\n * const point: Coordinate = { x: 1, y: 0 };\n * \n * // Rotate 90 degrees clockwise (π/2 radians)\n * const rotated90 = rotateByClockWise(Math.PI / 2, point);  // { x: 0, y: -1 }\n * \n * // Rotate 180 degrees (π radians)\n * const rotated180 = rotateByClockWise(Math.PI, point);     // { x: -1, y: 0 }\n * \n * // Rotate 45 degrees\n * const rotated45 = rotateByClockWise(Math.PI / 4, { x: 1, y: 1 });\n * // Result: approximately { x: 1.414, y: 0 }\n * ```\n */\nexport const rotateByClockWise = (theta: number, coord: Coordinate): Coordinate => {\n    const rotationMatrix = rotationByThetaClockWise(theta);\n    return multiply(rotationMatrix, coord);\n}\n\n/**\n * Inverts a coordinate by negating both components.\n * Equivalent to multiplying by -1 or rotating 180 degrees around origin.\n * \n * @param coord - The coordinate to invert\n * @returns The inverted coordinate\n * \n * @example\n * ```typescript\n * const point: Coordinate = { x: 3, y: -4 };\n * const inverted = invert(point);  // { x: -3, y: 4 }\n * \n * // Useful for direction reversal\n * const velocity: Coordinate = { x: 10, y: 5 };\n * const oppositeDirection = invert(velocity);  // { x: -10, y: -5 }\n * \n * // Double inversion returns original\n * const original = invert(invert(point));  // { x: 3, y: -4 }\n * ```\n */\nexport const invert = (coord: Coordinate): Coordinate => {\n    return multiplyScalar(-1, coord);\n}\n\n// =============================================================================\n// Compilation Test Examples\n// =============================================================================\n\n// getOrigin examples\nconst origin = getOrigin();  // { x: 0, y: 0 }\n\n// Use as starting point for calculations\nconst offset = addCoordinates(origin, { x: 10, y: 20 });\n\n// linearCombination examples\nconst a: Coordinate = { x: 2, y: 3 };\nconst b: Coordinate = { x: 4, y: 1 };\n\n// 2 * a + 3 * b = 2*(2,3) + 3*(4,1) = (4,6) + (12,3) = (16,9)\nconst result = linearCombination(2, a, 3, b);  // { x: 16, y: 9 }\n\n// Weighted average: 0.7 * a + 0.3 * b\nconst blend = linearCombination(0.7, a, 0.3, b);\n\n// multiplyScalar examples\nconst coord: Coordinate = { x: 3, y: 4 };\n\nconst doubled = multiplyScalar(2, coord);     // { x: 6, y: 8 }\nconst halved = multiplyScalar(0.5, coord);    // { x: 1.5, y: 2 }\nconst negated = multiplyScalar(-1, coord);    // { x: -3, y: -4 }\n\n// addCoordinates examples\nconst pointA: Coordinate = { x: 2, y: 3 };\nconst offsetValue: Coordinate = { x: 5, y: -1 };\n\nconst addResult = addCoordinates(pointA, offsetValue);  // { x: 7, y: 2 }\n\n// Chain multiple additions\nconst final = addCoordinates(\n  addCoordinates(pointA, offsetValue),\n  { x: 1, y: 1 }\n);  // { x: 8, y: 3 }\n\n// subtractCoordinates examples\nconst endPoint: Coordinate = { x: 10, y: 8 };\nconst startPoint: Coordinate = { x: 3, y: 2 };\n\nconst displacement = subtractCoordinates(endPoint, startPoint);  // { x: 7, y: 6 }\n\n// Calculate distance vector\nconst from: Coordinate = { x: 1, y: 1 };\nconst to: Coordinate = { x: 4, y: 5 };\nconst vector = subtractCoordinates(to, from);  // { x: 3, y: 4 }\n\n// reflectOnXAxis examples\nconst point: Coordinate = { x: 3, y: 4 };\nconst reflectedX = reflectOnXAxis(point);  // { x: 3, y: -4 }\n\n// Mirror across horizontal axis\nconst upperPoint: Coordinate = { x: 2, y: 5 };\nconst lowerPoint = reflectOnXAxis(upperPoint);  // { x: 2, y: -5 }\n\n// reflectOnYAxis examples\nconst reflectedY = reflectOnYAxis(point);  // { x: -3, y: 4 }\n\n// Mirror across vertical axis\nconst rightPoint: Coordinate = { x: 5, y: 2 };\nconst leftPoint = reflectOnYAxis(rightPoint);  // { x: -5, y: 2 }\n\n// rotateByClockWise examples\nconst pointForRotation: Coordinate = { x: 1, y: 0 };\n\n// Rotate 90 degrees clockwise (π/2 radians)\nconst rotated90 = rotateByClockWise(Math.PI / 2, pointForRotation);  // { x: 0, y: -1 }\n\n// Rotate 180 degrees (π radians)\nconst rotated180 = rotateByClockWise(Math.PI, pointForRotation);     // { x: -1, y: 0 }\n\n// Rotate 45 degrees\nconst rotated45 = rotateByClockWise(Math.PI / 4, { x: 1, y: 1 });\n// Result: approximately { x: 1.414, y: 0 }\n\n// invert examples\nconst pointToInvert: Coordinate = { x: 3, y: -4 };\nconst inverted = invert(pointToInvert);  // { x: -3, y: 4 }\n\n// Useful for direction reversal\nconst velocity: Coordinate = { x: 10, y: 5 };\nconst oppositeDirection = invert(velocity);  // { x: -10, y: -5 }\n\n// Double inversion returns original\nconst originalBack = invert(invert(pointToInvert));  // { x: 3, y: -4 }\n\n","/**\n * @fileoverview Coordinate metrics and geometric calculations for 2D vectors.\n * Provides mathematical operations for measuring distances, angles, and spatial relationships.\n * @module CoordinateMetrics\n */\n\nimport { Coordinate } from \"./coordinateTypes\"\n\n/**\n * Calculates the dot product of two vectors.\n * Returns the scalar product a·b = ax*bx + ay*by.\n * \n * @param a - First vector\n * @param b - Second vector\n * @returns The dot product scalar value\n * \n * @example\n * ```typescript\n * const a: Coordinate = { x: 3, y: 4 };\n * const b: Coordinate = { x: 2, y: 1 };\n * \n * const dotProduct = dot(a, b);  // 3*2 + 4*1 = 10\n * \n * // Perpendicular vectors have dot product of 0\n * const perpA: Coordinate = { x: 1, y: 0 };\n * const perpB: Coordinate = { x: 0, y: 1 };\n * const perpDot = dot(perpA, perpB);  // 0\n * \n * // Parallel vectors have maximum dot product\n * const parallel = dot(a, a);  // 25 (same as ||a||²)\n * ```\n */\nexport const dot = (a:Coordinate, b:Coordinate): number => {\n    return a.x * b.x + a.y * b.y;\n}\n\n/**\n * Calculates the Euclidean norm (magnitude/length) of a vector.\n * Returns ||v|| = √(x² + y²).\n * \n * @param v - The vector to measure\n * @returns The length of the vector\n * \n * @example\n * ```typescript\n * const v: Coordinate = { x: 3, y: 4 };\n * const length = norm(v);  // √(3² + 4²) = √25 = 5\n * \n * // Unit vector has length 1\n * const unit: Coordinate = { x: 1, y: 0 };\n * const unitLength = norm(unit);  // 1\n * \n * // Zero vector has length 0\n * const zero = norm({ x: 0, y: 0 });  // 0\n * ```\n */\nexport const norm = (v:Coordinate): number => {\n    return Math.sqrt(dot(v, v));\n}\n\n/**\n * Calculates the Euclidean distance between two points.\n * Returns ||b - a|| = √((bx-ax)² + (by-ay)²).\n * \n * @param a - First point\n * @param b - Second point\n * @returns The distance between the points\n * \n * @example\n * ```typescript\n * const pointA: Coordinate = { x: 0, y: 0 };\n * const pointB: Coordinate = { x: 3, y: 4 };\n * \n * const dist = distance(pointA, pointB);  // 5\n * \n * // Distance from point to itself is 0\n * const selfDist = distance(pointA, pointA);  // 0\n * \n * // Distance is symmetric\n * const dist1 = distance(pointA, pointB);\n * const dist2 = distance(pointB, pointA);  // same as dist1\n * ```\n */\nexport const distance = (a:Coordinate, b:Coordinate): number => {\n    return norm({ x: b.x - a.x, y: b.y - a.y });\n}\n\n/**\n * Normalizes a vector to unit length (length = 1).\n * Returns v/||v|| for non-zero vectors, or zero vector for zero input.\n * \n * @param v - The vector to normalize\n * @returns The unit vector in the same direction, or zero vector if input is zero\n * \n * @example\n * ```typescript\n * const v: Coordinate = { x: 3, y: 4 };\n * const unit = normalize(v);  // { x: 0.6, y: 0.8 }\n * \n * // Verify it's a unit vector\n * const length = norm(unit);  // 1 (approximately)\n * \n * // Zero vector normalizes to zero\n * const zero = normalize({ x: 0, y: 0 });  // { x: 0, y: 0 }\n * \n * // Direction vectors\n * const right = normalize({ x: 10, y: 0 });  // { x: 1, y: 0 }\n * const diagonal = normalize({ x: 1, y: 1 }); // { x: 0.707..., y: 0.707... }\n * ```\n */\nexport const normalize = (v:Coordinate): Coordinate => {\n    const len = norm(v);\n    if (len === 0) {\n        return { x: 0, y: 0 };\n    }\n    return { x: v.x / len, y: v.y / len };\n}\n\n/**\n * Calculates the angle between two vectors in radians.\n * Returns the acute angle (0 to π) between the vectors.\n * \n * @param a - First vector\n * @param b - Second vector\n * @returns The angle in radians (0 to π)\n * \n * @example\n * ```typescript\n * const right: Coordinate = { x: 1, y: 0 };\n * const up: Coordinate = { x: 0, y: 1 };\n * \n * const angle = angleBetween(right, up);  // π/2 (90 degrees)\n * \n * // Parallel vectors\n * const parallel = angleBetween(right, { x: 2, y: 0 });  // 0\n * \n * // Opposite vectors\n * const opposite = angleBetween(right, { x: -1, y: 0 });  // π (180 degrees)\n * \n * // Convert to degrees\n * const degrees = angle * (180 / Math.PI);  // 90\n * ```\n */\nexport const angleBetween = (a:Coordinate, b:Coordinate): number => {\n    const dotProduct = dot(a, b);\n    const lengthsProduct = norm(a) * norm(b);\n    if (lengthsProduct === 0) {\n        return 0;\n    }\n    let cosTheta = dotProduct / lengthsProduct;\n    // Clamp the value to the valid range of acos to avoid NaN due to floating point errors\n    cosTheta = Math.max(-1, Math.min(1, cosTheta));\n    return Math.acos(cosTheta);\n}\n\n/**\n * Calculates the axis-aligned bounding box of a set of points.\n * Returns the minimum and maximum coordinates that contain all points.\n * \n * @param points - Array of coordinates to bound\n * @returns Object with min and max coordinates, or origin box if empty array\n * \n * @example\n * ```typescript\n * const points: Coordinate[] = [\n *   { x: 1, y: 2 },\n *   { x: 5, y: 1 },\n *   { x: 3, y: 6 },\n *   { x: 0, y: 3 }\n * ];\n * \n * const box = boundingBox(points);\n * // Result: {\n * //   min: { x: 0, y: 1 },\n * //   max: { x: 5, y: 6 }\n * // }\n * \n * // Empty array returns origin box\n * const emptyBox = boundingBox([]);  // { min: {0,0}, max: {0,0} }\n * \n * // Single point\n * const singleBox = boundingBox([{ x: 3, y: 4 }]);\n * // Result: { min: {3,4}, max: {3,4} }\n * ```\n */\nexport const boundingBox = (points: Coordinate[]): { min: Coordinate; max: Coordinate } => {\n\n    if (points.length === 0) {\n        return { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } };\n    }\n    let minX = points[0].x;\n    let minY = points[0].y;\n    let maxX = points[0].x;\n    let maxY = points[0].y;\n\n    for (const point of points) {\n        if (point.x < minX) minX = point.x;\n        if (point.y < minY) minY = point.y;\n        if (point.x > maxX) maxX = point.x;\n        if (point.y > maxY) maxY = point.y;\n    }\n\n    return {\n        min: { x: minX, y: minY },\n        max: { x: maxX, y: maxY }\n    };\n}\n\n/**\n * Linear interpolation between two coordinates.\n * Returns a + t * (b - a) where t=0 gives a, t=1 gives b.\n * \n * @param a - Starting coordinate (t=0)\n * @param b - Ending coordinate (t=1)\n * @param t - Interpolation parameter (0 to 1 for interpolation, outside for extrapolation)\n * @returns The interpolated coordinate\n * \n * @example\n * ```typescript\n * const start: Coordinate = { x: 0, y: 0 };\n * const end: Coordinate = { x: 10, y: 20 };\n * \n * const middle = lerp(start, end, 0.5);    // { x: 5, y: 10 }\n * const quarter = lerp(start, end, 0.25);  // { x: 2.5, y: 5 }\n * const atStart = lerp(start, end, 0);     // { x: 0, y: 0 }\n * const atEnd = lerp(start, end, 1);       // { x: 10, y: 20 }\n * \n * // Extrapolation (t > 1 or t < 0)\n * const beyond = lerp(start, end, 1.5);    // { x: 15, y: 30 }\n * const before = lerp(start, end, -0.5);   // { x: -5, y: -10 }\n * ```\n */\nexport const lerp = (a:Coordinate, b:Coordinate, t:number): Coordinate => {\n    return {\n        x: a.x + (b.x - a.x) * t,\n        y: a.y + (b.y - a.y) * t,\n    };\n}\n\n/**\n * Clamps a coordinate to stay within specified bounds.\n * Constrains each component to the range [min, max].\n * \n * @param v - The coordinate to clamp\n * @param min - Minimum allowed values for each component\n * @param max - Maximum allowed values for each component\n * @returns The clamped coordinate\n * \n * @example\n * ```typescript\n * const point: Coordinate = { x: 15, y: -5 };\n * const minBounds: Coordinate = { x: 0, y: 0 };\n * const maxBounds: Coordinate = { x: 10, y: 10 };\n * \n * const clamped = clamp(point, minBounds, maxBounds);\n * // Result: { x: 10, y: 0 }\n * \n * // Already within bounds\n * const inside: Coordinate = { x: 5, y: 3 };\n * const unchanged = clamp(inside, minBounds, maxBounds);\n * // Result: { x: 5, y: 3 }\n * \n * // Useful for keeping coordinates in viewport\n * const screenBounds = { min: { x: 0, y: 0 }, max: { x: 1920, y: 1080 } };\n * ```\n */\nexport const clamp = (v:Coordinate, min:Coordinate, max:Coordinate): Coordinate => {\n    return {\n        x: Math.max(min.x, Math.min(max.x, v.x)),\n        y: Math.max(min.y, Math.min(max.y, v.y)),\n    };\n}\n\n\n","/**\n * @fileoverview Coordinate utility functions for common operations.\n * Provides helper functions for coordinate manipulation, comparison, and copying.\n * @module CoordinatesUtils\n */\n\nimport { Coordinate } from \"./coordinateTypes\";\n\n/**\n * Returns a coordinate with the minimum x and y values from two input coordinates.\n * Performs component-wise minimum operation.\n * \n * @param a - First coordinate\n * @param b - Second coordinate\n * @returns Coordinate with min(a.x, b.x) and min(a.y, b.y)\n * \n * @example\n * ```typescript\n * const pointA: Coordinate = { x: 5, y: 10 };\n * const pointB: Coordinate = { x: 3, y: 15 };\n * \n * const min = minCoordinate(pointA, pointB);  // { x: 3, y: 10 }\n * \n * // Useful for bounding box calculations\n * const topLeft = minCoordinate(\n *   { x: 100, y: 50 },\n *   { x: 80, y: 70 }\n * );  // { x: 80, y: 50 }\n * \n * // Works with negative coordinates\n * const negative = minCoordinate(\n *   { x: -5, y: 2 },\n *   { x: 3, y: -8 }\n * );  // { x: -5, y: -8 }\n * ```\n */\nexport const minCoordinate = (a: Coordinate, b: Coordinate): Coordinate => {\n    return { x: Math.min(a.x, b.x), y: Math.min(a.y, b.y) };\n}\n\n/**\n * Returns a coordinate with the maximum x and y values from two input coordinates.\n * Performs component-wise maximum operation.\n * \n * @param a - First coordinate\n * @param b - Second coordinate\n * @returns Coordinate with max(a.x, b.x) and max(a.y, b.y)\n * \n * @example\n * ```typescript\n * const pointA: Coordinate = { x: 5, y: 10 };\n * const pointB: Coordinate = { x: 3, y: 15 };\n * \n * const max = maxCoordinate(pointA, pointB);  // { x: 5, y: 15 }\n * \n * // Useful for bounding box calculations\n * const bottomRight = maxCoordinate(\n *   { x: 100, y: 50 },\n *   { x: 80, y: 70 }\n * );  // { x: 100, y: 70 }\n * \n * // Combined with minCoordinate for bounding box\n * const points = [{ x: 10, y: 5 }, { x: 3, y: 12 }, { x: 8, y: 2 }];\n * const min = points.reduce(minCoordinate);\n * const max = points.reduce(maxCoordinate);\n * // Bounding box: { min: {3, 2}, max: {10, 12} }\n * ```\n */\nexport const maxCoordinate = (a: Coordinate, b: Coordinate): Coordinate => {\n    return { x: Math.max(a.x, b.x), y: Math.max(a.y, b.y) };\n}\n\n/**\n * Creates a shallow copy of a coordinate.\n * Returns a new coordinate object with the same x and y values.\n * \n * @param coord - The coordinate to copy\n * @returns A new coordinate with identical values\n * \n * @example\n * ```typescript\n * const original: Coordinate = { x: 10, y: 20 };\n * const copy = copyCoordinate(original);  // { x: 10, y: 20 }\n * \n * // Modifications to copy don't affect original\n * copy.x = 30;\n * console.log(original.x);  // Still 10\n * console.log(copy.x);     // Now 30\n * \n * // Useful for immutable operations\n * const points: Coordinate[] = [\n *   { x: 1, y: 2 },\n *   { x: 3, y: 4 }\n * ];\n * const copiedPoints = points.map(copyCoordinate);\n * \n * // Safe transformation without mutation\n * const transformedPoint = copyCoordinate(original);\n * transformedPoint.x += 5;\n * transformedPoint.y *= 2;\n * ```\n */\nexport const copyCoordinate = (coord: Coordinate): Coordinate => {\n    return { x: coord.x, y: coord.y };\n}\n\n","import { Coordinate, copyCoordinate } from \"../geometry\";\nimport { GridBox } from \"./gridBoxTypes\";\n\n\n\n/** \n * Creates a normalized {@link GridBox} from an origin and a diagonal vector.\n *\n * @remarks\n * - This function does not attach the box to any global grid; the coordinates\n *   are interpreted in an abstract local reference system.\n * - `origin` is treated as a position for the bottom-left corner.\n * - `diagonal` is treated as a size/extent vector; its components are made\n *   non-negative so that the resulting box has a well-defined width and height.\n *\n * @param origin - Bottom-left corner of the box in local coordinates.\n * @param diagonal - Vector from `origin` toward the opposite corner. Its `x`\n * and `y` components may be negative on input; they are converted to absolute\n * values during normalization.\n *\n * @returns A normalized {@link GridBox} where `diagonal.x` and `diagonal.y`\n * are guaranteed to be non-negative.\n */\nexport const makeGridBox = (origin: Coordinate, diagonal: Coordinate): GridBox => {\n    const org = copyCoordinate(origin);\n    const diag = copyCoordinate(diagonal);\n\n    diag.x = Math.abs(diag.x);\n    diag.y = Math.abs(diag.y);\n\n    return {\n        origin: org,\n        diagonal: diag,\n        _normalized: 'GridBox',\n    };\n};\n\n/**\n * Creates a deep copy of an existing {@link GridBox}.\n *\n * @remarks\n * The returned box preserves the `_normalized` brand and assumes that the\n * input already satisfies the `GridBox` invariants.\n *\n * @param box - The box to copy.\n * @returns A new {@link GridBox} with copied `origin` and `diagonal`.\n */\nexport const copyGridBox = (box: GridBox): GridBox => {\n    return {\n        origin: copyCoordinate(box.origin),\n        diagonal: copyCoordinate(box.diagonal),\n        _normalized: 'GridBox',\n    };\n};\n\n\n\n\n\n\n\n\n\n\n\n","/**\n * @fileoverview Default implementations of box transformation functions for CSS Grid layout system.\n * Provides concrete implementations for all transformation operations defined in boxTransformationsProps.\n * These functions modify box positions and dimensions in a sparse map object structure.\n * @module DefaultBoxTransformations\n */\n\nimport { boxPosition } from \"../box/boxPositions\";\nimport { GridBox } from \"../box/gridBoxTypes\";\nimport { makeGridBox } from \"../box/gridBoxUtils\";\nimport { Coordinate, addCoordinates, subtractCoordinates } from \"../geometry\";\nimport { DiagnosticEntry, GRID_ERROR_CODE, makeError } from \"../gridErrorShape\";\nimport { NodeID } from \"../templates/layoutIDs\";\nimport {\n    AllBoxMovesProps,\n    BoxMovesFunctions,\n    BoxMovesFunctionsProps,\n    BoxPropBase\n} from \"./boxTransformationsProps\";\n\n/**\n * Utility function to resolve coordinate targets from various input types.\n * Handles conversion from numbers, coordinates, or box anchor references to actual coordinates.\n * This is a key function used throughout the transformation system to normalize target positions.\n * \n * @param to - The target specification (number, coordinate, or box anchor reference)\n * @param boxes - Sparse map object containing all available boxes\n * @param diagnostics - Array to record any errors encountered during resolution\n * @param source - The transformation type making this call (for error reporting)\n * @returns The resolved coordinate, or undefined if resolution failed\n * \n * @example\n * ```typescript\n * // Resolve from number\n * const coord1 = getCoordinateBoxTo(100, boxes, diagnostics, \"moveTo\");\n * // Result: { x: 100, y: 100 }\n * \n * // Resolve from coordinate\n * const coord2 = getCoordinateBoxTo({ x: 50, y: 75 }, boxes, diagnostics, \"moveTo\");\n * // Result: { x: 50, y: 75 }\n * \n * // Resolve from box anchor\n * const coord3 = getCoordinateBoxTo(\n *   { boxId: 'block_1', anchor: 'topLeft' }, \n *   boxes, \n *   diagnostics, \n *   \"moveTo\"\n * );\n * // Result: coordinate of block_1's topLeft anchor\n * ```\n */\nfunction getCoordinateBoxTo(\n  to: number | Coordinate | BoxPropBase<NodeID>,\n  boxes: Partial<Record<NodeID, GridBox>>,\n  diagnostics: DiagnosticEntry[],\n  source: AllBoxMovesProps<any>\n): Coordinate | undefined {\n  let toPoint: Coordinate;\n\n  if (typeof to === \"number\") {\n    toPoint = { x: to, y: to };\n  } else if (\"x\" in to && \"y\" in to) {\n    toPoint = { x: to.x, y: to.y };\n  } else if (\"boxId\" in to && \"anchor\" in to) {\n    const boxTo = boxes[to.boxId];\n\n    if (!boxTo) {\n      diagnostics.push(\n        makeError(\n          source,\n          GRID_ERROR_CODE.UNKNOWN_NODE_ID,\n          `${source} transformation has invalid 'to' boxId: ${to.boxId}`\n        )\n      );\n      return undefined;\n    }\n\n    const anchorCoord = boxPosition(boxTo, to.anchor);\n\n    if (!anchorCoord) {\n      diagnostics.push(\n        makeError(\n          source,\n          GRID_ERROR_CODE.UNKNOWN_ANCHOR,\n          `${source} transformation has invalid 'to' anchor: ${to.anchor}`\n        )\n      );\n      return undefined;\n    }\n    toPoint = anchorCoord;\n  } else {\n    diagnostics.push(\n      makeError(\n        source,\n        GRID_ERROR_CODE.INVALID_TRANSFORMATION_PARAMS,\n        `${source} transformation has invalid 'to' parameter`\n      )\n    );\n    return undefined;\n  }\n\n  return toPoint;\n}\n\n/**\n * Helper function to validate the existence of a source box in transformations.\n * Ensures that the specified box ID exists in the boxes collection before proceeding with transformations.\n * \n * @param boxId - The box identifier to validate\n * @param boxes - Sparse map object containing all available boxes\n * @param diagnostics - Array to record validation errors\n * @param source - The transformation type making this call (for error reporting)\n * @returns The validated GridBox, or undefined if validation failed\n * \n * @example\n * ```typescript\n * const validBox = validateBoxFrom('block_1', boxes, diagnostics, \"moveTo\");\n * if (validBox) {\n *   // Proceed with transformation using validBox\n * } else {\n *   // Handle validation failure (error already recorded in diagnostics)\n * }\n * ```\n */\nfunction validateBoxFrom(\n  boxId: NodeID,\n  boxes: Partial<Record<NodeID, GridBox>>,\n  diagnostics: DiagnosticEntry[],\n  source: AllBoxMovesProps<any>\n): GridBox | undefined {\n  const boxFrom = boxes[boxId];\n  if (!boxFrom) {\n    diagnostics.push(\n      makeError(\n        source,\n        GRID_ERROR_CODE.UNKNOWN_NODE_ID,\n        `${source} transformation has invalid 'from' boxId: ${boxId}`\n      )\n    );\n    return undefined;\n  }\n\n  return boxFrom;\n}\n\n/**\n * Moves a box to a specific target position.\n * Calculates the displacement needed to move the specified anchor of the source box\n * to align with the target position, then applies this displacement to the entire box.\n * \n * The transformation:\n * 1. Validates the source box exists\n * 2. Resolves the target position (absolute coordinate or another box's anchor)\n * 3. Calculates displacement from source anchor to target\n * 4. Applies optional gap offset\n * 5. Creates new box with adjusted origin\n * 6. Updates the boxes collection in-place\n * \n * @param props - MoveTo transformation properties including source, target, and optional gap\n * @returns The transformed GridBox, or undefined if transformation failed\n * \n * @example\n * ```typescript\n * // Move aside's center to block_1's topLeft\n * const result = moveTo({\n *   boxprops: {\n *     from: { boxId: 'aside', anchor: 'center' },\n *     to: { boxId: 'block_1', anchor: 'topLeft' },\n *     gap: { x: 10, y: 5 }\n *   },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * ```\n */\nconst moveTo = (props: BoxMovesFunctionsProps<NodeID>[\"moveTo\"]) => {\n  const { boxprops, boxes, diagnostics } = props;\n\n  const { from, to, gap } = boxprops;\n\n  const boxFrom = validateBoxFrom(from.boxId, boxes, diagnostics, \"moveTo\");\n\n  if (!boxFrom) {\n    return undefined;\n  }\n\n  let toPoint = getCoordinateBoxTo(to, boxes, diagnostics, \"moveTo\");\n\n  if (!toPoint) {\n    return undefined;\n  }\n\n  const fromAnchor = boxPosition(boxFrom, from.anchor);\n  if (!fromAnchor) {\n    diagnostics.push(\n      makeError(\n        \"moveTo\",\n        GRID_ERROR_CODE.UNKNOWN_ANCHOR,\n        `moveTo transformation has invalid 'from' anchor: ${from.anchor}`\n      )\n    );\n    return undefined;\n  }\n\n  if (gap !== undefined) {\n    toPoint = addCoordinates(toPoint, gap);\n  }\n  const displacement = subtractCoordinates(toPoint, fromAnchor);\n\n  let newOrigin = addCoordinates(boxFrom.origin, displacement);\n\n  const newBox = makeGridBox(newOrigin, boxFrom.diagonal);\n\n  boxes[from.boxId] = newBox;\n\n  return newBox;\n};\n\n/**\n * Moves a box by a specified relative amount.\n * Applies a translation vector to the box's current position, moving it by the specified offset.\n * Unlike moveTo, this operation is relative to the box's current position rather than absolute.\n * \n * The transformation:\n * 1. Validates the source box exists\n * 2. Converts the 'by' parameter to a coordinate delta (handles both number and Coordinate types)\n * 3. Applies optional gap offset to the delta\n * 4. Adds the delta to the box's current origin\n * 5. Creates new box with the translated origin\n * 6. Updates the boxes collection in-place\n * \n * @param props - MoveBy transformation properties including source box and movement delta\n * @returns The transformed GridBox, or undefined if transformation failed\n * \n * @example\n * ```typescript\n * // Move box by coordinate offset\n * const result1 = moveBy({\n *   boxprops: {\n *     from: { boxId: 'aside' },\n *     by: { x: 100, y: 50 },\n *     gap: { x: 5, y: 5 }\n *   },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * \n * // Move box by uniform amount\n * const result2 = moveBy({\n *   boxprops: {\n *     from: { boxId: 'sidebar' },\n *     by: 25\n *   },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * ```\n */\nconst moveBy = (props: BoxMovesFunctionsProps<NodeID>[\"moveBy\"]) => {\n  const { boxprops, boxes, diagnostics } = props;\n  const { from, by, gap } = boxprops;\n\n  const boxFrom = validateBoxFrom(from.boxId, boxes, diagnostics, \"moveBy\");\n\n  if (!boxFrom) {\n    return undefined;\n  }\n\n  let delta: Coordinate;\n  if (typeof by === \"number\") {\n    delta = { x: by, y: by };\n  } else if (\"x\" in by && \"y\" in by) {\n    delta = by;\n  } else {\n    diagnostics.push(\n      makeError(\n        \"moveBy\",\n        GRID_ERROR_CODE.INVALID_TRANSFORMATION_PARAMS,\n        `moveBy transformation has invalid 'by' parameter`\n      )\n    );\n    return undefined;\n  }\n\n  if (gap !== undefined) {\n    delta = addCoordinates(delta, gap);\n  }\n\n  const newOrigin = addCoordinates(boxFrom.origin, delta);\n\n  const newBox = makeGridBox(newOrigin, boxFrom.diagonal);\n\n  boxes[from.boxId] = newBox;\n\n  return newBox;\n};\n\n/**\n * Aligns a box's Y-coordinate to a specific target while preserving its X-coordinate.\n * Moves the specified anchor of the source box vertically to match the target Y position.\n * The X-coordinate of the box remains unchanged, creating a pure vertical alignment.\n * \n * The transformation:\n * 1. Validates the source box exists\n * 2. Resolves the target position (absolute Y or another box's anchor)\n * 3. Preserves the current X position by setting toPoint.x = fromAnchor.x\n * 4. Calculates vertical displacement needed\n * 5. Applies optional gap offset to the Y displacement\n * 6. Creates new box with adjusted origin\n * 7. Updates the boxes collection in-place\n * \n * @param props - AlignToY transformation properties including source, target Y position, and optional gap\n * @returns The transformed GridBox, or undefined if transformation failed\n * \n * @example\n * ```typescript\n * // Align to absolute Y position\n * const result1 = alignToY({\n *   boxprops: {\n *     from: { boxId: 'block_4', anchor: 'bottomLeft' },\n *     to: 300,\n *     gap: 10\n *   },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * \n * // Align to another box's Y position\n * const result2 = alignToY({\n *   boxprops: {\n *     from: { boxId: 'sidebar', anchor: 'center' },\n *     to: { boxId: 'header', anchor: 'bottomLeft' }\n *   },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * ```\n */\nconst alignToY = (props: BoxMovesFunctionsProps<NodeID>[\"alignToY\"]) => {\n  const { boxprops, boxes, diagnostics } = props;\n\n  const { from, to, gap } = boxprops;\n\n  const boxFrom = validateBoxFrom(from.boxId, boxes, diagnostics, \"alignToY\");\n\n  if (!boxFrom) {\n    return undefined;\n  }\n\n  const toPoint = getCoordinateBoxTo(to, boxes, diagnostics, \"alignToY\");\n\n  if (!toPoint) {\n    return undefined;\n  }\n\n  const fromAnchor = boxPosition(boxFrom, from.anchor);\n  if (!fromAnchor) {\n    diagnostics.push(\n      makeError(\n        \"alignToY\",\n        GRID_ERROR_CODE.UNKNOWN_ANCHOR,\n        `alignToY transformation has invalid 'from' anchor: ${from.anchor}`\n      )\n    );\n    return undefined;\n  }\n\n  toPoint.x = fromAnchor.x;\n\n  const displacement = subtractCoordinates(toPoint, fromAnchor);\n\n  if (gap !== undefined) {\n    displacement.y += gap;\n  }\n\n  let newOrigin = addCoordinates(boxFrom.origin, displacement);\n\n  const newBox = makeGridBox(newOrigin, boxFrom.diagonal);\n\n  boxes[from.boxId] = newBox;\n\n  return newBox;\n};\n\n/**\n * Aligns a box's X-coordinate to a specific target while preserving its Y-coordinate.\n * Moves the specified anchor of the source box horizontally to match the target X position.\n * The Y-coordinate of the box remains unchanged, creating a pure horizontal alignment.\n * \n * The transformation:\n * 1. Validates the source box exists\n * 2. Resolves the target position (absolute X or another box's anchor)\n * 3. Preserves the current Y position by setting toPoint.y = fromAnchor.y\n * 4. Calculates horizontal displacement needed\n * 5. Applies optional gap offset to the X displacement\n * 6. Creates new box with adjusted origin\n * 7. Updates the boxes collection in-place\n * \n * @param props - AlignToX transformation properties including source, target X position, and optional gap\n * @returns The transformed GridBox, or undefined if transformation failed\n * \n * @example\n * ```typescript\n * // Align to absolute X position\n * const result1 = alignToX({\n *   boxprops: {\n *     from: { boxId: 'nav', anchor: 'topLeft' },\n *     to: 150,\n *     gap: 20\n *   },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * \n * // Align to another box's X position\n * const result2 = alignToX({\n *   boxprops: {\n *     from: { boxId: 'sidebar', anchor: 'topRight' },\n *     to: { boxId: 'main', anchor: 'topLeft' }\n *   },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * ```\n */\nconst alignToX = (props: BoxMovesFunctionsProps<NodeID>[\"alignToX\"]) => {\n  const { boxprops, boxes, diagnostics } = props;\n  const { from, to, gap } = boxprops;\n\n  const boxFrom = validateBoxFrom(from.boxId, boxes, diagnostics, \"alignToX\");\n\n  if (!boxFrom) {\n    return undefined;\n  }\n\n  const toPoint = getCoordinateBoxTo(to, boxes, diagnostics, \"alignToX\");\n\n  if (!toPoint) {\n    return undefined;\n  }\n\n  const fromAnchor = boxPosition(boxFrom, from.anchor);\n  if (!fromAnchor) {\n    diagnostics.push(\n      makeError(\n        \"alignToX\",\n        GRID_ERROR_CODE.UNKNOWN_ANCHOR,\n        `alignToX transformation has invalid 'from' anchor: ${from.anchor}`\n      )\n    );\n    return undefined;\n  }\n\n  toPoint.y = fromAnchor.y;\n\n  const displacement = subtractCoordinates(toPoint, fromAnchor);\n\n  if (gap !== undefined) {\n    displacement.x += gap;\n  }\n\n  let newOrigin = addCoordinates(boxFrom.origin, displacement);\n\n  const newBox = makeGridBox(newOrigin, boxFrom.diagonal);\n\n  boxes[from.boxId] = newBox;\n\n  return newBox;\n};\n\n/**\n * Aligns all boxes to the same X-coordinate using a specified anchor point.\n * Iterates through all available boxes and applies X-alignment to each one,\n * creating a vertical line of aligned elements.\n * \n * The transformation:\n * 1. Iterates through all boxes in the collection\n * 2. Applies alignToX to each box using the specified anchor and target X position\n * 3. Collects successfully transformed boxes\n * 4. Updates the boxes collection in-place\n * 5. Returns the collection of transformed boxes\n * \n * @param props - AlignAllToX transformation properties including target X position and anchor\n * @returns Partial record of transformed boxes, or undefined if no boxes were processed\n * \n * @example\n * ```typescript\n * // Align all boxes' left edges to X=100\n * const result = alignAllToX({\n *   boxprops: {\n *     to: 100,\n *     anchor: 'topLeft'\n *   },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * ```\n */\nconst alignAllToX = (props: BoxMovesFunctionsProps<NodeID>[\"alignAllToX\"]) => {\n  const { boxprops, boxes, diagnostics } = props;\n  const { to, anchor } = boxprops;\n\n  let newBoxes: Partial<Record<NodeID, GridBox>> = {};\n\n  for (const boxId in boxes) {\n    const id = boxId as NodeID;\n    const newBox = alignToX({\n      boxprops: {\n        from: {\n          boxId: id,\n          anchor: anchor,\n        },\n        to: to,\n      },\n      boxes,\n      diagnostics,\n    });\n\n    if (newBox) {\n      newBoxes[id] = newBox;\n      boxes[id] = newBox;\n    }\n  }\n\n  if (Object.keys(newBoxes).length === 0) {\n    diagnostics.push(\n      makeError(\n        \"alignAllToX\",\n        GRID_ERROR_CODE.NO_BOXES_PROCESSED,\n        `alignAllToX transformation could not process any box`\n      )\n    );\n    return undefined;\n  }\n\n  return newBoxes;\n};\n\n/**\n * Aligns all boxes to the same Y-coordinate using a specified anchor point.\n * Iterates through all available boxes and applies Y-alignment to each one,\n * creating a horizontal line of aligned elements.\n * \n * The transformation:\n * 1. Iterates through all boxes in the collection\n * 2. Applies alignToY to each box using the specified anchor and target Y position\n * 3. Collects successfully transformed boxes\n * 4. Updates the boxes collection in-place\n * 5. Returns the collection of transformed boxes\n * \n * @param props - AlignAllToY transformation properties including target Y position and anchor\n * @returns Partial record of transformed boxes, or undefined if no boxes were processed\n * \n * @example\n * ```typescript\n * // Align all boxes' top edges to Y=200\n * const result = alignAllToY({\n *   boxprops: {\n *     to: 200,\n *     anchor: 'topLeft'\n *   },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * ```\n */\n// align all boxes to a given Y coordinate\nconst alignAllToY = (props: BoxMovesFunctionsProps<NodeID>[\"alignAllToY\"]) => {\n  const { boxprops, boxes, diagnostics } = props;\n  const { to, anchor } = boxprops;\n\n  let newBoxes: Partial<Record<NodeID, GridBox>> = {};\n\n  for (const boxId in boxes) {\n    const id = boxId as NodeID;\n\n    const newBox = alignToY({\n      boxprops: {\n        from: {\n          boxId: id,\n          anchor: anchor,\n        },\n        to: to,\n      },\n      boxes,\n      diagnostics,\n    });\n\n    if (newBox) {\n      newBoxes[id] = newBox;\n      boxes[id] = newBox;\n    }\n  }\n\n  if (Object.keys(newBoxes).length === 0) {\n    diagnostics.push(\n      makeError(\n        \"alignAllToY\",\n        GRID_ERROR_CODE.NO_BOXES_PROCESSED,\n        `alignAllToY transformation could not process any box`\n      )\n    );\n\n    return undefined;\n  }\n  return newBoxes;\n};\n\n/**\n * Arranges boxes in a horizontal stack with optional spacing.\n * Positions boxes side by side from left to right, with each box's left edge\n * aligned to the right edge of the previous box plus optional gap.\n * \n * The transformation:\n * 1. Starts with X position at 0\n * 2. For each box, aligns its bottomLeft anchor to current X position\n * 3. Updates X position to box's right edge plus gap\n * 4. Continues for all boxes, creating a horizontal sequence\n * 5. Updates the boxes collection in-place\n * \n * @param props - StackHorizontally transformation properties including optional gap\n * @returns Partial record of transformed boxes, or undefined if no boxes were processed\n * \n * @example\n * ```typescript\n * // Stack boxes horizontally with 20px gap\n * const result = stackHorizontally({\n *   boxprops: { gap: 20 },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * \n * // Stack boxes with no gap (touching edges)\n * const result2 = stackHorizontally({\n *   boxprops: {},\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * ```\n */\n// stack boxes horizontally with an optional gap\nconst stackHorizontally = (\n  props: BoxMovesFunctionsProps<NodeID>[\"stackHorizontally\"]\n) => {\n  const { boxprops, boxes, diagnostics } = props;\n  const { gap } = boxprops;\n\n  let newBoxes: Partial<Record<NodeID, GridBox>> = {};\n\n  let x0 = 0;\n\n  for (const boxId in boxes) {\n    const id = boxId as NodeID;\n    const newBox = alignToX({\n      boxprops: {\n        from: {\n          boxId: id,\n          anchor: \"bottomLeft\",\n        },\n        to: x0,\n      },\n      boxes,\n      diagnostics,\n    });\n\n    if (newBox) {\n      newBoxes[id] = newBox;\n      x0 += newBox.diagonal.x + (gap ? gap : 0);\n      boxes[id] = newBox;\n    }\n  }\n\n  if (Object.keys(newBoxes).length === 0) {\n    diagnostics.push(\n      makeError(\n        \"stackHorizontally\",\n        GRID_ERROR_CODE.NO_BOXES_PROCESSED,\n        `stackHorizontally transformation could not process any box`\n      )\n    );\n\n    return undefined;\n  }\n\n  return newBoxes;\n};\n\n/**\n * Arranges boxes in a vertical stack with optional spacing.\n * Positions boxes one above another from bottom to top, with each box's bottom edge\n * aligned to the top edge of the previous box plus optional gap.\n * \n * The transformation:\n * 1. Starts with Y position at 0\n * 2. For each box, aligns its bottomLeft anchor to current Y position\n * 3. Updates Y position to box's top edge plus gap\n * 4. Continues for all boxes, creating a vertical sequence\n * 5. Updates the boxes collection in-place\n * \n * @param props - StackVertically transformation properties including optional gap\n * @returns Partial record of transformed boxes, or undefined if no boxes were processed\n * \n * @example\n * ```typescript\n * // Stack boxes vertically with 15px gap\n * const result = stackVertically({\n *   boxprops: { gap: 15 },\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * \n * // Stack boxes with no gap (touching edges)\n * const result2 = stackVertically({\n *   boxprops: {},\n *   boxes: existingBoxes,\n *   diagnostics: []\n * });\n * ```\n */\n// stack boxes vertically with an optional gap\nconst stackVertically = (\n  props: BoxMovesFunctionsProps<NodeID>[\"stackVertically\"]\n) => {\n  const { boxprops, boxes, diagnostics } = props;\n  const { gap } = boxprops;\n\n  let newBoxes: Partial<Record<NodeID, GridBox>> = {};\n\n  let y0 = 0;\n\n  for (const boxId in boxes) {\n    const id = boxId as NodeID;\n    const newBox = alignToY({\n      boxprops: {\n        from: {\n          boxId: id,\n          anchor: \"bottomLeft\",\n        },\n        to: y0,\n      },\n      boxes,\n      diagnostics,\n    });\n\n    if (newBox) {\n      newBoxes[id] = newBox;\n      y0 += newBox.diagonal.y + (gap ? gap : 0);\n      boxes[id] = newBox;\n    }\n  }\n\n  if (Object.keys(newBoxes).length === 0) {\n    diagnostics.push(\n      makeError(\n        \"stackVertically\",\n        GRID_ERROR_CODE.NO_BOXES_PROCESSED,\n        `stackVertically transformation could not process any box`\n      )\n    );\n\n    return undefined;\n  }\n\n  return newBoxes;\n};\n\n/**\n * Factory function that creates the default transformation registry.\n * Returns a complete implementation of all box transformation functions\n * defined in the BoxMovesFunctions interface. This serves as the standard\n * implementation of the transformation system.\n * \n * The registry provides implementations for:\n * - `moveTo`: Move box to specific position or another box's anchor\n * - `moveBy`: Move box by relative amount\n * - `alignToY`: Align box vertically while preserving X position\n * - `alignToX`: Align box horizontally while preserving Y position\n * - `alignAllToX`: Align all boxes to same X coordinate\n * - `alignAllToY`: Align all boxes to same Y coordinate\n * - `stackHorizontally`: Arrange boxes in horizontal sequence\n * - `stackVertically`: Arrange boxes in vertical sequence\n * \n * @returns Complete registry of transformation functions\n * \n * @example\n * ```typescript\n * // Get the default transformation registry\n * const transformations = DefaultBoxTransformations();\n * \n * // Use a specific transformation\n * const result = transformations.moveTo({\n *   boxprops: {\n *     from: { boxId: 'block_1', anchor: 'center' },\n *     to: { x: 100, y: 200 }\n *   },\n *   boxes: myBoxes,\n *   diagnostics: []\n * });\n * \n * // Apply multiple transformations\n * transformations.stackHorizontally({\n *   boxprops: { gap: 20 },\n *   boxes: myBoxes,\n *   diagnostics: []\n * });\n * \n * transformations.alignAllToY({\n *   boxprops: { to: 100, anchor: 'center' },\n *   boxes: myBoxes,\n *   diagnostics: []\n * });\n * ```\n */\n// the factory of default transformations\n// a registry of all verbs\nexport const DefaultBoxTransformations = (): BoxMovesFunctions<NodeID> => {\n  return {\n    moveTo: moveTo,\n\n    moveBy: moveBy,\n\n    alignToY: alignToY,\n\n    alignToX: alignToX,\n\n    alignAllToX: alignAllToX,\n\n    alignAllToY: alignAllToY,\n\n    stackHorizontally: stackHorizontally,\n\n    stackVertically: stackVertically,\n  };\n};\n\n// =============================================================================\n// Compilation Test Examples\n// =============================================================================\n\n// Mock data for testing\nconst existingBoxes: Partial<Record<NodeID, GridBox>> = {\n  'block_1': makeGridBox({ x: 0, y: 0 }, { x: 100, y: 50 }),\n  'aside': makeGridBox({ x: 150, y: 100 }, { x: 80, y: 60 }),\n  'sidebar': makeGridBox({ x: 0, y: 200 }, { x: 60, y: 120 }),\n  'nav': makeGridBox({ x: 200, y: 0 }, { x: 120, y: 40 }),\n  'header': makeGridBox({ x: 50, y: 300 }, { x: 200, y: 80 }),\n  'main': makeGridBox({ x: 120, y: 150 }, { x: 180, y: 140 }),\n  'block_4': makeGridBox({ x: 300, y: 50 }, { x: 90, y: 70 })\n};\n\nconst myBoxes: Partial<Record<NodeID, GridBox>> = {\n  'block_1': makeGridBox({ x: 10, y: 10 }, { x: 50, y: 50 }),\n  'block_2': makeGridBox({ x: 70, y: 10 }, { x: 50, y: 50 }),\n  'block_3': makeGridBox({ x: 130, y: 10 }, { x: 50, y: 50 })\n};\n\nlet diagnostics: DiagnosticEntry[] = [];\nlet boxes = { ...existingBoxes };\n\n// getCoordinateBoxTo examples\n// Resolve from number\nconst coord1 = getCoordinateBoxTo(100, boxes, diagnostics, \"moveTo\");\n// Result: { x: 100, y: 100 }\n\n// Resolve from coordinate\nconst coord2 = getCoordinateBoxTo({ x: 50, y: 75 }, boxes, diagnostics, \"moveTo\");\n// Result: { x: 50, y: 75 }\n\n// Resolve from box anchor\nconst coord3 = getCoordinateBoxTo(\n  { boxId: 'block_1', anchor: 'topLeft' }, \n  boxes, \n  diagnostics, \n  \"moveTo\"\n);\n// Result: coordinate of block_1's topLeft anchor\n\n// validateBoxFrom example\nconst validBox = validateBoxFrom('block_1', boxes, diagnostics, \"moveTo\");\nif (validBox) {\n  // Proceed with transformation using validBox\n} else {\n  // Handle validation failure (error already recorded in diagnostics)\n}\n\n// moveTo example\n// Move aside's center to block_1's topLeft\nconst moveToResult = moveTo({\n  boxprops: {\n    from: { boxId: 'aside', anchor: 'center' },\n    to: { boxId: 'block_1', anchor: 'topLeft' },\n    gap: { x: 10, y: 5 }\n  },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// moveBy examples\n// Move box by coordinate offset\nconst moveByResult1 = moveBy({\n  boxprops: {\n    from: { boxId: 'aside' },\n    by: { x: 100, y: 50 },\n    gap: { x: 5, y: 5 }\n  },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// Move box by uniform amount\nconst moveByResult2 = moveBy({\n  boxprops: {\n    from: { boxId: 'sidebar' },\n    by: 25\n  },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// alignToY examples\n// Align to absolute Y position\nconst alignToYResult1 = alignToY({\n  boxprops: {\n    from: { boxId: 'block_4', anchor: 'bottomLeft' },\n    to: 300,\n    gap: 10\n  },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// Align to another box's Y position\nconst alignToYResult2 = alignToY({\n  boxprops: {\n    from: { boxId: 'sidebar', anchor: 'center' },\n    to: { boxId: 'header', anchor: 'bottomLeft' }\n  },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// alignToX examples\n// Align to absolute X position\nconst alignToXResult1 = alignToX({\n  boxprops: {\n    from: { boxId: 'nav', anchor: 'topLeft' },\n    to: 150,\n    gap: 20\n  },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// Align to another box's X position\nconst alignToXResult2 = alignToX({\n  boxprops: {\n    from: { boxId: 'sidebar', anchor: 'topRight' },\n    to: { boxId: 'main', anchor: 'topLeft' }\n  },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// alignAllToX example\n// Align all boxes' left edges to X=100\nconst alignAllToXResult = alignAllToX({\n  boxprops: {\n    to: 100,\n    anchor: 'topLeft'\n  },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// alignAllToY example\n// Align all boxes' top edges to Y=200\nconst alignAllToYResult = alignAllToY({\n  boxprops: {\n    to: 200,\n    anchor: 'topLeft'\n  },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// stackHorizontally examples\n// Stack boxes horizontally with 20px gap\nconst stackHorizontallyResult1 = stackHorizontally({\n  boxprops: { gap: 20 },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// Stack boxes with no gap (touching edges)\nconst stackHorizontallyResult2 = stackHorizontally({\n  boxprops: {},\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// stackVertically examples\n// Stack boxes vertically with 15px gap\nconst stackVerticallyResult1 = stackVertically({\n  boxprops: { gap: 15 },\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// Stack boxes with no gap (touching edges)\nconst stackVerticallyResult2 = stackVertically({\n  boxprops: {},\n  boxes: { ...existingBoxes },\n  diagnostics: []\n});\n\n// DefaultBoxTransformations examples\n// Get the default transformation registry\nconst transformations = DefaultBoxTransformations();\n\n// Use a specific transformation\nconst factoryResult = transformations.moveTo({\n  boxprops: {\n    from: { boxId: 'block_1', anchor: 'center' },\n    to: { x: 100, y: 200 }\n  },\n  boxes: { ...myBoxes },\n  diagnostics: []\n});\n\n// Apply multiple transformations\nconst stackResult = transformations.stackHorizontally({\n  boxprops: { gap: 20 },\n  boxes: { ...myBoxes },\n  diagnostics: []\n});\n\nconst alignResult = transformations.alignAllToY({\n  boxprops: { to: 100, anchor: 'center' },\n  boxes: { ...myBoxes },\n  diagnostics: []\n});\n","/**\n * @fileoverview Box transformation properties and types for CSS Grid layout system.\n * Provides comprehensive type definitions for transforming boxes within layouts,\n * including movement, alignment, and stacking operations.\n * @module BoxTransformationsProps\n */\n\nimport { Anchor, GridBox } from \"../../src/box/gridBoxTypes\";\nimport { Coordinate } from \"../geometry\";\nimport { DiagnosticEntry } from \"../gridErrorShape\";\nimport { NodeID } from \"../templates/layoutIDs\";\n\n/**\n * Base properties for box transformations.\n * Defines the fundamental structure for identifying a box and its reference point.\n * The localIDs are the NodeIDs that can be used in box layouts.\n * \n * @template BoxIDFrom - The type of box identifier that can be transformed\n * \n * @example\n * ```typescript\n * const baseProps: BoxPropBase<'block_1'> = {\n *   boxId: 'block_1',\n *   anchor: 'topLeft'\n * };\n * ```\n */\nexport type BoxPropBase<BoxIDFrom extends NodeID> = {\n  /** The identifier of the box to transform */\n  boxId: BoxIDFrom;\n  /** The anchor point on the box to use as reference for transformations */\n  anchor: Anchor;\n};\n\n/**\n * Properties for moving a box to a specific position.\n * Enables moving a box from its current position to either absolute coordinates\n * or relative to another box's anchor point.\n * \n * @template BoxID - The type of box identifier that can be moved\n * \n * @example\n * ```typescript\n * // Move to absolute coordinates\n * const moveToAbsolute: BoxMoveToProps<'aside'> = {\n *   from: { boxId: 'aside', anchor: 'center' },\n *   to: { x: 100, y: 200 },\n *   gap: { x: 10, y: 5 }\n * };\n * \n * // Move to another box's position\n * const moveToBox: BoxMoveToProps<'aside' | 'block_1'> = {\n *   from: { boxId: 'aside', anchor: 'center' },\n *   to: { boxId: 'block_1', anchor: 'topLeft' }\n * };\n * ```\n */\nexport type BoxMoveToProps<BoxID extends NodeID> = {\n  /** The source box and its reference anchor */\n  from: BoxPropBase<BoxID>;\n  /** Target position - either absolute coordinates or another box's anchor */\n  to: Coordinate | BoxPropBase<BoxID>;\n  /** Optional gap to maintain from the target position */\n  gap?: Coordinate;\n};\n/**\n * Properties for moving a box by a relative amount.\n * Enables translating a box from its current position by specified offsets.\n * Note: anchor is omitted as the movement is relative to the entire box.\n * \n * @template BoxIDFrom - The type of box identifier that can be moved\n * \n * @example\n * ```typescript\n * // Move by coordinate offset\n * const moveByCoord: BoxMoveByProps<'aside'> = {\n *   from: { boxId: 'aside' },\n *   by: { x: 100, y: 200 },\n *   gap: { x: 5, y: 5 }\n * };\n * \n * // Move by uniform amount\n * const moveByUniform: BoxMoveByProps<'block_1'> = {\n *   from: { boxId: 'block_1' },\n *   by: 50\n * };\n * ```\n */\nexport type BoxMoveByProps<BoxIDFrom extends NodeID> = {\n  /** The source box (anchor not needed for relative movement) */\n  from: Omit<BoxPropBase<BoxIDFrom>, \"anchor\">;\n  /** Movement offset - either coordinate object or uniform number */\n  by: Coordinate | number;\n  /** Optional gap to add to the movement */\n  gap?: Coordinate;\n};\n\n/**\n * Properties for aligning a box to a specific Y-coordinate or another box's Y-position.\n * Enables vertical alignment operations within the layout.\n * \n * @template BoxID - The type of box identifier that can be aligned\n * \n * @example\n * ```typescript\n * // Align to absolute Y position\n * const alignToY: BoxAlignYProps<'block_4'> = {\n *   from: { boxId: 'block_4', anchor: 'bottomLeft' },\n *   to: 300,\n *   gap: 10\n * };\n * \n * // Align to another box's Y position\n * const alignToBoxY: BoxAlignYProps<'block_1' | 'block_2'> = {\n *   from: { boxId: 'block_1', anchor: 'center' },\n *   to: { boxId: 'block_2', anchor: 'topLeft' }\n * };\n * ```\n */\nexport type BoxAlignYProps<BoxID extends NodeID> = {\n  /** The source box and its reference anchor */\n  from: BoxPropBase<BoxID>;\n  /** Target Y position - either absolute number or another box's anchor */\n  to: number | BoxPropBase<BoxID>;\n  /** Optional gap to maintain from the target Y position */\n  gap?: number;\n};\n\n/**\n * Properties for aligning a box to a specific X-coordinate or another box's X-position.\n * Enables horizontal alignment operations within the layout.\n * \n * @template BoxID - The type of box identifier that can be aligned\n * \n * @example\n * ```typescript\n * // Align to absolute X position\n * const alignToX: BoxAlignXProps<'sidebar'> = {\n *   from: { boxId: 'sidebar', anchor: 'topLeft' },\n *   to: 150,\n *   gap: 20\n * };\n * \n * // Align to another box's X position\n * const alignToBoxX: BoxAlignXProps<'nav' | 'header'> = {\n *   from: { boxId: 'nav', anchor: 'topRight' },\n *   to: { boxId: 'header', anchor: 'topRight' }\n * };\n * ```\n */\nexport type BoxAlignXProps<BoxID extends NodeID> = {\n  /** The source box and its reference anchor */\n  from: BoxPropBase<BoxID>;\n  /** Target X position - either absolute number or another box's anchor */\n  to: number | BoxPropBase<BoxID>;\n  /** Optional gap to maintain from the target X position */\n  gap?: number;\n};\n\n/**\n * Union type of all possible box transformation properties.\n * Enables type-safe handling of any individual box transformation operation.\n * \n * @template BoxID - The type of box identifier that can be transformed\n * \n * @example\n * ```typescript\n * const transforms: BoxProps<'block_1' | 'aside'>[] = [\n *   { from: { boxId: 'aside', anchor: 'center' }, to: { x: 100, y: 200 } },\n *   { from: { boxId: 'block_1' }, by: 50 },\n *   { from: { boxId: 'aside', anchor: 'top' }, to: 300, gap: 10 }\n * ];\n * ```\n */\nexport type BoxProps<BoxID extends NodeID> =\n  | BoxMoveToProps<BoxID>\n  | BoxMoveByProps<BoxID>\n  | BoxAlignYProps<BoxID>\n  | BoxAlignXProps<BoxID>;\n\n/**\n * Comprehensive database of all possible box transformation operations.\n * Maps transformation names to their corresponding property types.\n * Ensures all transformation IDs correspond to meaningful transformation properties.\n * \n * @template BoxID - The type of box identifier that can be transformed\n * \n * @example\n * ```typescript\n * // Individual transformation examples\n * const moveTransform: BoxMovesPropsObject<'block_1'>['moveTo'] = {\n *   from: { boxId: 'block_1', anchor: 'center' },\n *   to: { x: 100, y: 200 }\n * };\n * \n * const stackTransform: BoxMovesPropsObject<'block_1'>['stackVertically'] = {\n *   gap: 20\n * };\n * \n * const alignAllTransform: BoxMovesPropsObject<'block_1'>['alignAllToX'] = {\n *   to: 150,\n *   anchor: 'left'\n * };\n * ```\n */\nexport type BoxMovesPropsObject<BoxID extends NodeID> = {\n  /** Move a box to a specific position or another box's anchor */\n  moveTo: BoxMoveToProps<BoxID>;\n  /** Move a box by a relative amount */\n  moveBy: BoxMoveByProps<BoxID>;\n  /** Align a box to a specific Y-coordinate or another box's Y-position */\n  alignToY: BoxAlignYProps<BoxID>;\n  /** Align a box to a specific X-coordinate or another box's X-position */\n  alignToX: BoxAlignXProps<BoxID>;\n  /** Align all boxes to the same Y-coordinate using specified anchor */\n  alignAllToY: { to: number; anchor: Anchor };\n  /** Align all boxes to the same X-coordinate using specified anchor */\n  alignAllToX: { to: number; anchor: Anchor };\n  /** Stack all boxes vertically with optional gap */\n  stackVertically: { gap?: number };\n  /** Stack all boxes horizontally with optional gap */\n  stackHorizontally: { gap?: number };\n};\n\n/**\n * Extract transformation IDs from the box transformations object.\n * Provides type-safe access to all available transformation names.\n * \n * @template BoxID - The type of box identifier\n */\nexport type TransformationIDs<BoxID extends NodeID> =\n  keyof BoxMovesPropsObject<BoxID>;\n\n/**\n * Constant array of all available transformation IDs.\n * Ensures compile-time verification that all transformations are accounted for.\n * \n * @example\n * ```typescript\n * // Iterate through all available transformations\n * transformationIDs.forEach(id => {\n *   console.log(`Available transformation: ${id}`);\n * });\n * ```\n */\nexport const transformationIDs = [\n  \"moveTo\",\n  \"moveBy\",\n  \"alignToY\",\n  \"alignToX\",\n  \"alignAllToY\",\n  \"alignAllToX\",\n  \"stackVertically\",\n  \"stackHorizontally\",\n] as const satisfies readonly TransformationIDs<any>[];\n\n/**\n * Discriminated union type for box transformation properties.\n * Enables type-safe handling of transformations where each transformation\n * is identified by its unique key and contains the corresponding properties.\n * \n * @template BoxID - The type of box identifier that can be transformed\n * \n * @example\n * ```typescript\n * const transformations: Array<BoxMovesProps<'block_1' | 'aside'>> = [\n *   {\n *     moveTo: {\n *       from: { boxId: 'aside', anchor: 'center' },\n *       to: { boxId: 'block_1', anchor: 'topLeft' }\n *     }\n *   },\n *   {\n *     moveBy: {\n *       from: { boxId: 'aside' },\n *       by: { x: 100, y: 200 }\n *     }\n *   },\n *   {\n *     stackVertically: { gap: 20 }\n *   }\n * ];\n * ```\n */\nexport type BoxMovesProps<BoxID extends NodeID> = {\n  [M in keyof BoxMovesPropsObject<any>]: {\n    [K in M]: BoxMovesPropsObject<BoxID>[M];\n  };\n}[keyof BoxMovesPropsObject<any>];\n\n/**\n * Union type of all possible box transformation identifiers.\n * Provides access to the keys of all available transformations.\n * \n * @template BoxID - The type of box identifier that can be transformed\n */\nexport type AllBoxMovesProps<BoxID extends NodeID> =\n  keyof BoxMovesPropsObject<BoxID>;\n\n/**\n * Properties that transformation functions will receive.\n * Defines the input structure for each transformation implementation,\n * including the transformation properties, current box state, and diagnostics.\n * \n * @template BoxID - The type of box identifier that can be transformed\n * \n * @example\n * ```typescript\n * // Function props for moveTo transformation\n * const moveToProps: BoxMovesFunctionsProps<'block_1'>['moveTo'] = {\n *   boxprops: {\n *     from: { boxId: 'block_1', anchor: 'center' },\n *     to: { x: 100, y: 200 }\n *   },\n *   boxes: {\n *     'block_1': { origin: { x: 0, y: 0 }, diagonal: { x: 4, y: 4 }, _normalized: 'GridBox' }\n *   },\n *   diagnostics: []\n * };\n * ```\n */\nexport type BoxMovesFunctionsProps<BoxID extends NodeID> = {\n  [M in keyof BoxMovesPropsObject<any>]: {\n    /** The specific transformation properties */\n    boxprops: BoxMovesPropsObject<BoxID>[M];\n    /** Current state of all boxes in the layout */\n    boxes: Partial<Record<NodeID, GridBox>>;\n    /** Array for recording diagnostic information and errors */\n    diagnostics: DiagnosticEntry[];\n  };\n};\n\n/**\n * Function signatures for implementing box transformations.\n * Defines the expected signature for each transformation function,\n * ensuring consistent interfaces across all transformation implementations.\n * \n * Each function:\n * - Receives transformation properties, current boxes state, and diagnostics array\n * - Returns either a single transformed GridBox, undefined, or partial record of boxes\n * - May modify the diagnostics array to record errors or warnings\n * - Assumes in-place transformation of the boxes array\n * \n * @template BoxID - The type of box identifier that can be transformed\n * \n * @example\n * ```typescript\n * // Implementation example for moveTo function\n * const moveToImpl: BoxMovesFunctions<'block_1'>['moveTo'] = (props) => {\n *   const { boxprops, boxes, diagnostics } = props;\n *   const sourceBox = boxes[boxprops.from.boxId];\n *   \n *   if (!sourceBox) {\n *     diagnostics.push({\n *       level: 'error',\n *       message: `Box ${boxprops.from.boxId} not found`\n *     });\n *     return undefined;\n *   }\n *   \n *   // Transform the box...\n *   return transformedBox;\n * };\n * ```\n */\nexport type BoxMovesFunctions<BoxID extends NodeID> = {\n  [M in keyof BoxMovesPropsObject<any>]: (\n    props: BoxMovesFunctionsProps<BoxID>[M]\n  ) => GridBox | undefined | Partial<Record<NodeID, GridBox>>;\n};\n\n/**\n * @example Example Usage Scenarios\n * \n * ```typescript\n * // Array of multiple transformations\n * let transformations: Array<BoxMovesProps<'block_1' | 'aside'>> = [\n *   {\n *     moveTo: {\n *       from: {\n *         boxId: 'aside',\n *         anchor: 'center'\n *       },\n *       to: {\n *         boxId: 'block_1',\n *         anchor: 'topLeft'\n *       }\n *     }\n *   },\n *   {\n *     moveBy: {\n *       from: {\n *         boxId: 'aside',\n *       },\n *       by: {\n *         x: 100,\n *         y: 200\n *       },\n *     }\n *   },\n *   {\n *     moveTo: {\n *       from: {\n *         boxId: 'aside',\n *         anchor: 'center'\n *       },\n *       to: {\n *         boxId: 'block_1',\n *         anchor: 'topLeft'\n *       }\n *     }\n *   },\n * ];\n * \n * // Single moveBy transformation\n * let moveByTransform: Partial<BoxMovesProps<'block_1' | 'aside' | 'block_4'>> = {\n *   moveBy: {\n *     from: { boxId: 'aside' },\n *     by: {\n *       x: 100,\n *       y: 200\n *     }\n *   }\n * };\n * \n * // Y-alignment transformation\n * let alignYTransform: Partial<BoxMovesProps<'block_1' | 'aside' | 'block_4'>> = {\n *   alignToY: {\n *     from: { boxId: 'block_4', anchor: 'bottomLeft' },\n *     to: 300\n *   }\n * };\n * ```\n */\n\n// =============================================================================\n// Compilation Test Examples\n// =============================================================================\n\n// Array of multiple transformations\nconst kii: Array<BoxMovesProps<'block_1' | 'aside'>> = [\n  {\n    moveTo: {\n      from: {\n        boxId: 'aside',\n        anchor: 'center'\n      },\n      to: {\n        boxId: 'block_1',\n        anchor: 'topLeft'\n      }\n    }\n  },\n  {\n    moveBy: {\n      from: {\n        boxId: 'aside',\n      },\n      by: {\n        x: 100,\n        y: 200\n      },\n    }\n  },\n  {\n    moveTo: {\n      from: {\n        boxId: 'aside',\n        anchor: 'center'\n      },\n      to: {\n        boxId: 'block_1',\n        anchor: 'topLeft'\n      }\n    }\n  },\n];\n\n// Single moveBy transformation\nconst rt: BoxMovesProps<'block_1' | 'aside' | 'block_4'> = {\n  moveBy: {\n    from: {\n      boxId: 'aside'\n    },\n    by: {\n      x: 100,\n      y: 200\n    }\n  }\n};\n\n// Y-alignment transformation\nconst rt1: BoxMovesProps<'block_1' | 'aside' | 'block_4'> = {\n  alignToY: {\n    from: {\n      boxId: 'block_4',\n      anchor: 'bottomLeft'\n    },\n    to: 300\n  }\n};\n\n// Additional examples for other transformation types\nconst stackVerticallyExample: BoxMovesProps<'block_1' | 'block_2'> = {\n  stackVertically: {\n    gap: 20\n  }\n};\n\nconst stackHorizontallyExample: BoxMovesProps<'nav' | 'sidebar'> = {\n  stackHorizontally: {\n    gap: 10\n  }\n};\n\nconst alignAllToYExample: BoxMovesProps<'header' | 'footer'> = {\n  alignAllToY: {\n    to: 100,\n    anchor: 'topLeft'\n  }\n};\n\nconst alignAllToXExample: BoxMovesProps<'sidebar' | 'main'> = {\n  alignAllToX: {\n    to: 50,\n    anchor: 'topLeft'\n  }\n};\n\nconst alignToXExample: BoxMovesProps<'nav' | 'header'> = {\n  alignToX: {\n    from: {\n      boxId: 'nav',\n      anchor: 'topRight'\n    },\n    to: {\n      boxId: 'header',\n      anchor: 'topRight'\n    },\n    gap: 5\n  }\n};\n\n// Test with coordinate targets\nconst moveToCoordinateExample: BoxMovesProps<'block_1'> = {\n  moveTo: {\n    from: {\n      boxId: 'block_1',\n      anchor: 'center'\n    },\n    to: {\n      x: 150,\n      y: 200\n    },\n    gap: {\n      x: 10,\n      y: 5\n    }\n  }\n};\n\n// Test with number for moveBy\nconst moveByNumberExample: BoxMovesProps<'aside'> = {\n  moveBy: {\n    from: {\n      boxId: 'aside'\n    },\n    by: 50\n  }\n};\n","/**\n * Transform Box Move Engine\n * \n * This module provides the core transformation engine that applies box movement and alignment\n * transformations to grid layouts. It processes transformation configurations across all\n * responsive breakpoints and applies them using a pluggable transformation factory.\n * \n * Supported Transformations:\n * - moveTo: Position box at specific coordinates\n * - moveBy: Translate box by offset amounts\n * - alignToX/alignToY: Align box to specific coordinate\n * - alignAllToX/alignAllToY: Align multiple boxes to same coordinate\n * - stackVertically/stackHorizontally: Arrange boxes in stacks\n * \n * The engine is type-safe and provides comprehensive error handling with detailed\n * diagnostic reporting for transformation failures.\n */\n\n// Grid box type definitions\nimport { GridBox } from \"../box/gridBoxTypes\";\n\n// Box transformation configuration types\nimport { BoxTransformations } from \"../boxLayout\";\n\n// Transformation function interfaces and type definitions\nimport { \n  BoxMovesFunctions,      // Factory interface for transformation functions\n  BoxMovesProps,          // Union type of all transformation properties\n  TransformationIDs,      // Valid transformation identifier types\n  BoxMovesPropsObject,    // Object mapping transformation IDs to properties\n  transformationIDs,      // Runtime array of valid transformation IDs\n  BoxMoveToProps          // Specific properties for moveTo transformation\n} from \"../boxTransformations\";\n\n// Responsive breakpoint types and constants\nimport { BPs, BREAKPOINTS } from \"../breakpoints\";\n\n// Error handling and diagnostic utilities\nimport { DiagnosticEntry, makeError, GRID_ERROR_CODE } from \"../gridErrorShape\";\n\n// Node identifier types\nimport { NodeID } from \"../templates\";\n\n\n/**\n * Apply box movement transformations across all responsive breakpoints\n * \n * This is the main transformation engine that processes box transformation configurations\n * and applies them to grid layouts. It handles multiple transformation types and provides\n * comprehensive error handling and diagnostic reporting.\n * \n * Processing Flow:\n * 1. Iterate through each responsive breakpoint (xs, sm, md, lg, xl)\n * 2. For each breakpoint, process all configured transformations in sequence\n * 3. Validate transformation types and apply using the transformation factory\n * 4. Report errors and constraint violations through diagnostics\n * \n * @template BoxID - Type extending NodeID for box identifiers\n * @param transformationFactory - Factory providing transformation function implementations\n * @param boxTransformations - Configuration of transformations per breakpoint\n * @param gridBoxes - Grid boxes to transform, organized by breakpoint\n * @param diagnostics - Array to collect errors and warnings during processing\n */\nexport const transformBoxMove = <BoxID extends NodeID>(\n    transformationFactory: BoxMovesFunctions<BoxID>,\n    boxTransformations: BoxTransformations<BoxID>,\n    gridBoxes: BPs<Partial<Record<BoxID, GridBox>>>,\n    diagnostics: DiagnosticEntry[]) => {\n\n\n    // Process transformations for each responsive breakpoint\n    BREAKPOINTS.forEach(bp => {\n\n        // Skip breakpoints that have no transformation configurations\n        if (!(bp in boxTransformations)) {\n            return; // no transformations for this breakpoint\n        }\n\n        // Get transformation array for current breakpoint\n        const transformationsAtBp: Array<BoxMovesProps<BoxID>> | undefined = boxTransformations[bp];\n\n        // Skip if no transformations are defined for this breakpoint\n        if (!transformationsAtBp) {\n            return; // nothing to do\n        }\n\n        // Process each transformation in sequence for this breakpoint\n        // Order matters: transformations are applied sequentially and may depend on previous results\n        transformationsAtBp.forEach(tx => {\n\n            const tr: BoxMovesProps<BoxID> = tx;\n\n            // Extract transformation type from the transformation object\n            // Each transformation object has exactly one key indicating its type\n            const txID: TransformationIDs<BoxID> = Object.keys(tr)[0] as keyof BoxMovesPropsObject<BoxID>;\n\n            // Validate that the transformation type is recognized\n            if (!transformationIDs.includes(txID)) {\n                // unknown transformation ID\n                diagnostics.push(makeError('transformBoxMove',\n                    GRID_ERROR_CODE.UNKNOWN_TRANSFORMATION,\n                    `Unknown transformation key: ${txID}`));\n                return;\n            }\n\n            // Apply the appropriate transformation based on its type\n            // Each case handles a specific transformation type with proper type casting\n            switch (txID) {\n                case \"moveTo\":\n                    // Move box to absolute coordinates\n                    // console.log('Applying moveTo transformation', tr);\n                    {\n                        const propsMove = (tr as { moveTo: BoxMoveToProps<BoxID> }).moveTo;\n                        \n                        // Apply the moveTo transformation using the factory\n                        let result = transformationFactory.moveTo({\n                            boxprops: propsMove,\n                            boxes: gridBoxes[bp],\n                            diagnostics: diagnostics\n                        });\n\n                        // Report failure if transformation couldn't be applied\n                        if (!result) {\n                            diagnostics.push(makeError('transformBoxMove',\n                                GRID_ERROR_CODE.CONSTRAINT_VIOLATION,\n                                `moveTo transformation failed for box ${JSON.stringify(propsMove)}`));\n                        }\n                    }\n                    break;\n                case \"moveBy\":\n                    // Move box by relative offset amounts\n                    // console.log('Applying moveBy transformation', tr);\n                    {\n                        const propsMoveBy = (tr as { moveBy: any }).moveBy;\n                        \n                        // Apply the moveBy transformation using the factory\n                        let result = transformationFactory.moveBy({\n                            boxprops: propsMoveBy,\n                            boxes: gridBoxes[bp],\n                            diagnostics: diagnostics\n                        });\n\n                        // Report failure if transformation couldn't be applied\n                        if (!result) {\n                            diagnostics.push(makeError('transformBoxMove',\n                                GRID_ERROR_CODE.CONSTRAINT_VIOLATION,\n                                `moveBy transformation failed for box ${JSON.stringify(propsMoveBy)}`));\n                        }\n                    }\n                    break;\n                case \"alignToY\":\n                    // Align box to specific Y coordinate\n                    // console.log('Applying alignToY transformation', tr);\n                    {\n                        const propsAlignY = (tr as { alignToY: any }).alignToY;\n                        \n                        // Apply the alignToY transformation using the factory\n                        let result = transformationFactory.alignToY({\n                            boxprops: propsAlignY,\n                            boxes: gridBoxes[bp],\n                            diagnostics: diagnostics\n                        });\n\n                        // Report failure if transformation couldn't be applied\n                        if (!result) {\n                            diagnostics.push(makeError('transformBoxMove',\n                                GRID_ERROR_CODE.CONSTRAINT_VIOLATION,\n                                `alignToY transformation failed for box ${JSON.stringify(propsAlignY)}`));\n                        }\n                    }\n\n                    break;\n                case \"alignToX\":\n                    // Align box to specific X coordinate\n                    // console.log('Applying alignToX transformation', tr);\n                    {\n                        const propsAlignX = (tr as { alignToX: any }).alignToX;\n                        \n                        // Apply the alignToX transformation using the factory\n                        let result = transformationFactory.alignToX({\n                            boxprops: propsAlignX,\n                            boxes: gridBoxes[bp],\n                            diagnostics: diagnostics\n                        });\n\n                        // Report failure if transformation couldn't be applied\n                        if (!result) {\n                            diagnostics.push(makeError('transformBoxMove',\n                                GRID_ERROR_CODE.CONSTRAINT_VIOLATION,\n                                `alignToX transformation failed for box ${JSON.stringify(propsAlignX)}`));\n                        }\n                    }\n\n                    break;\n                case \"alignAllToY\":\n                    // Align multiple boxes to the same Y coordinate\n                    // console.log('Applying alignAllToY transformation', tr);\n                    {\n                        const propsAlignAllY = (tr as { alignAllToY: any }).alignAllToY;\n                        \n                        // Apply the alignAllToY transformation using the factory\n                        let result = transformationFactory.alignAllToY({\n                            boxprops: propsAlignAllY,\n                            boxes: gridBoxes[bp],\n                            diagnostics: diagnostics\n                        });\n\n                        // Report failure if transformation couldn't be applied\n                        if (!result) {\n                            diagnostics.push(makeError('transformBoxMove',\n                                GRID_ERROR_CODE.CONSTRAINT_VIOLATION,\n                                `alignAllToY transformation failed for box ${JSON.stringify(propsAlignAllY)}`));\n                        }\n                    }\n                    break;\n                case \"alignAllToX\":\n                    // Align multiple boxes to the same X coordinate\n                    // console.log('Applying alignAllToX transformation', tr);\n                    {\n                        const propsAlignAllX = (tr as { alignAllToX: any }).alignAllToX;\n                        \n                        // Apply the alignAllToX transformation using the factory\n                        let result = transformationFactory.alignAllToX({\n                            boxprops: propsAlignAllX,\n                            boxes: gridBoxes[bp],\n                            diagnostics: diagnostics\n                        });\n\n                        // Report failure if transformation couldn't be applied\n                        if (!result) {\n                            diagnostics.push(makeError('transformBoxMove',\n                                GRID_ERROR_CODE.CONSTRAINT_VIOLATION,\n                                `alignAllToX transformation failed for box ${JSON.stringify(propsAlignAllX)}`));\n                        }\n                    }\n\n                    break;\n                case \"stackVertically\":\n                    // Arrange boxes in a vertical stack (one above the other)\n                    // console.log('Applying stackVertically transformation', tr);\n                    {\n                        const propsStackV = (tr as { stackVertically: any }).stackVertically;\n                        \n                        // Apply the stackVertically transformation using the factory\n                        let result = transformationFactory.stackVertically({\n                            boxprops: propsStackV,\n                            boxes: gridBoxes[bp],\n                            diagnostics: diagnostics\n                        });\n\n                        // Report failure if transformation couldn't be applied\n                        if (!result) {\n                            diagnostics.push(makeError('transformBoxMove',\n                                GRID_ERROR_CODE.CONSTRAINT_VIOLATION,\n                                `stackVertically transformation failed for box ${JSON.stringify(propsStackV)}`));\n                        }\n                    }\n                    break;\n                case \"stackHorizontally\":\n                    // Arrange boxes in a horizontal stack (side by side)\n                    // console.log('Applying stackHorizontally transformation', tr);\n                    {\n                        const propsStackH = (tr as { stackHorizontally: any }).stackHorizontally;\n                        \n                        // Apply the stackHorizontally transformation using the factory\n                        let result = transformationFactory.stackHorizontally({\n                            boxprops: propsStackH,\n                            boxes: gridBoxes[bp],\n                            diagnostics: diagnostics\n                        });\n\n                        // Report failure if transformation couldn't be applied\n                        if (!result) {\n                            diagnostics.push(makeError('transformBoxMove',\n                                GRID_ERROR_CODE.CONSTRAINT_VIOLATION,\n                                `stackHorizontally transformation failed for box ${JSON.stringify(propsStackH)}`));\n                        }\n                    }\n                    break;\n\n                default:\n                    // TypeScript exhaustiveness checking: this should never be reached\n                    // If we get here, there's a transformation ID that wasn't handled above\n                    diagnostics.push(makeError('transformBoxMove',\n                        GRID_ERROR_CODE.UNKNOWN_TRANSFORMATION,\n                        `Unhandled transformation key: ${txID}`));\n\n                    // TypeScript exhaustiveness check - this will cause a compile error\n                    // if any transformation cases are missing from the switch statement\n                    const _exhaustive: never = txID;\n                    break;\n\n            }\n        }); // End of transformations loop for current breakpoint\n\n    }); // End of breakpoints loop\n\n    // Transformation processing complete\n    // All configured transformations have been applied across all breakpoints\n    // Any errors or constraint violations have been reported through diagnostics\n\n}\n\n","/**\n * Layout Section Bounds to Absolute\n * \n * This module converts layout sections with bounding boxes to absolute CSS grid coordinates.\n * It performs coordinate transformations to position sections and their contained boxes\n * in absolute CSS grid coordinates, handling responsive breakpoints and ensuring\n * all coordinates are positive (≥1) as required by CSS Grid specification.\n * \n * The transformation process involves:\n * 1. Converting box positions from local to relative-to-bounding-box coordinates\n * 2. Positioning bounding boxes at (1,1) and applying transformations\n * 3. Converting relative positions back to absolute coordinates\n * 4. Normalizing all coordinates to ensure they are ≥1\n */\n\n// Grid box type definitions\nimport { GridBox } from '../box/gridBoxTypes';\n\n// Layout structure types for absolute positioning and transformations\nimport {\n  BoxesCoordinates,\n  BoxTransformations,\n  LayoutAbsolute,\n  LayoutSectionBounds,\n} from '../boxLayout/boxLayoutTypes';\n\n// Default transformation configurations\nimport { DefaultBoxTransformations } from '../boxTransformations/defaultBoxTransformations';\n\n// Responsive breakpoint definitions and types\nimport { BPs, BREAKPOINTS } from '../breakpoints';\n\n// Coordinate manipulation utilities\nimport { subtractCoordinates, addCoordinates, Coordinate } from '../geometry';\n\n// Error handling and diagnostic utilities\nimport { DiagnosticEntry, GRID_ERROR_CODE, makeWarning } from '../gridErrorShape';\n\n// CSS coordinate type definitions\nimport { CSSCoordinates } from '../gridNodeTypes';\n\n// Template identifiers for sections and blocks\nimport { SectionIDs, BlocksIDs } from '../templates';\n\n// Box transformation utilities\nimport { transformBoxMove } from './transformBoxMove';\n\n/**\n * Extract valid section IDs from a partial record of sections\n * \n * Filters out null/undefined sections and returns only the keys\n * of sections that have actual content.\n * \n * @param sections - Partial record of sections with potential null/undefined values\n * @returns Array of valid section IDs that have non-null content\n */\nfunction layoutSectionKeys<sectionIDs extends SectionIDs>(\n  sections: Partial<Record<sectionIDs, unknown>>,\n): sectionIDs[] {\n  return Object.keys(sections).filter(\n    (k) => sections[k as sectionIDs] != null,\n  ) as Array<sectionIDs>;\n}\n\n/**\n * Convert layout sections with bounding boxes to absolute CSS grid coordinates\n * \n * This function performs a complex coordinate transformation process to convert\n * sections with bounded layouts into absolute CSS grid coordinates. The process\n * ensures all coordinates are valid for CSS Grid (≥1) and properly positioned.\n * \n * Transformation steps:\n * 1. Convert box origins from absolute to relative-to-bounding-box coordinates\n * 2. Position all bounding boxes at (1,1) as starting reference point\n * 3. Apply any configured transformations to bounding boxes\n * 4. Convert box coordinates back to absolute positions\n * 5. Calculate grid dimensions and normalize coordinates to positive values\n * \n * @template sectionIDs - Type representing the available section identifiers\n * @template blockIDs - Type representing the available block/box identifiers\n * @param layoutSectionBounds - Layout with sections and their calculated bounding boxes\n * @param diagnostics - Array to collect any errors or warnings during processing\n * @returns Layout with absolute CSS grid coordinates for all sections and boxes\n */\nexport function layoutSectionBtoAbsolute<sectionIDs extends SectionIDs, blockIDs extends BlocksIDs>(\n  layoutSectionBounds: LayoutSectionBounds<sectionIDs, blockIDs>,\n  diagnostics: DiagnosticEntry[],\n): LayoutAbsolute<sectionIDs, blockIDs> {\n  // Initialize the result object that will contain absolute coordinates\n  let LayoutAbsolute: LayoutAbsolute<sectionIDs, blockIDs> = {} as LayoutAbsolute<\n    sectionIDs,\n    blockIDs\n  >;\n\n  // Get default transformation settings (baseline transformations)\n  let defaultBoxTransformations = DefaultBoxTransformations();\n\n  // Use custom transformations if provided, otherwise use empty object\n  let transformations: BoxTransformations<sectionIDs> = layoutSectionBounds.transformations\n    ? layoutSectionBounds.transformations\n    : ({} as BoxTransformations<sectionIDs>);\n\n  // Extract valid section IDs for processing\n  const sections = layoutSectionKeys(layoutSectionBounds.sections);\n\n  // PHASE 1: Transform box origins to be relative to their bounding box origin\n  // This converts absolute positions within sections to displacement vectors\n  // from the section's bounding box origin\n  BREAKPOINTS.forEach((bp) => {\n    for (const sectionId of sections) {\n      // Get the bounding box for this section at this breakpoint\n      const boundBox: GridBox = layoutSectionBounds.boundingBoxes[bp][sectionId as sectionIDs];\n\n      // Get all boxes within this section at this breakpoint\n      const localBoxes = layoutSectionBounds.sections[sectionId as sectionIDs][bp];\n      if (!localBoxes) {\n        continue;\n      }\n      \n      // Convert each box's absolute position to relative position\n      for (const boxId in localBoxes) {\n        const box = localBoxes[boxId as blockIDs];\n        if (!box) {\n          continue;\n        }\n\n        // Subtract bounding box origin to get displacement from bounding box origin\n        // Example: if box is at (5,3) and bounding box origin is at (2,1),\n        // the relative position becomes (3,2)\n        box.origin = subtractCoordinates(box.origin, boundBox.origin);\n      }\n    }\n  });\n\n  // PHASE 2: Position all bounding boxes at standard reference point (1,1)\n  // This creates a common starting point before applying transformations\n  BREAKPOINTS.forEach((bp) => {\n    for (const sectionId of sections) {\n      const boundBox: GridBox = layoutSectionBounds.boundingBoxes[bp][sectionId];\n\n      // Move the bounding box origin to (1,1) - CSS Grid's minimum valid coordinate\n      boundBox.origin = { x: 1, y: 1 };\n    }\n  });\n\n  // PHASE 3: Apply transformations to bounding boxes\n  // This positions the bounding boxes according to configured transformations\n  // (e.g., stacking, spacing, alignment rules)\n  transformBoxMove<sectionIDs>(\n    defaultBoxTransformations,\n    transformations,\n    layoutSectionBounds.boundingBoxes,\n    diagnostics,\n  );\n\n  // PHASE 4: Convert box coordinates back to absolute positions\n  // Now that bounding boxes are in their final absolute positions,\n  // we can calculate the final absolute positions of all boxes\n  BREAKPOINTS.forEach((bp) => {\n    const localGridBoxesPerBp = layoutSectionBounds.boundingBoxes[bp];\n\n    for (const sectionId of sections) {\n      // Get the transformed bounding box (now in absolute CSS coordinates)\n      const boundBox: GridBox = localGridBoxesPerBp[sectionId];\n\n      // Process all boxes within this section\n      const localBoxes = layoutSectionBounds.sections[sectionId][bp];\n      if (!localBoxes) {\n        continue;\n      }\n      \n      for (const boxId in localBoxes) {\n        const box = localBoxes[boxId as blockIDs];\n        if (!box) {\n          continue;\n        }\n\n        // Add the bounding box origin to the relative position to get absolute position\n        // Example: if box displacement is (3,2) and bounding box origin is at (10,5),\n        // the final absolute position becomes (13,7)\n        box.origin = addCoordinates(box.origin, boundBox.origin);\n      }\n    }\n  });\n\n  // Initialize grid dimensions structure for storing calculated grid size\n  LayoutAbsolute.gridDimensions = {\n    rows: {} as BPs<number>,\n    columns: {} as BPs<number>,\n  };\n\n  // PHASE 5: Calculate overall grid dimensions for each breakpoint\n  // Find the maximum extents of all bounding boxes to determine grid size\n  BREAKPOINTS.forEach((bp) => {\n    const localGridBoxesPerBp = layoutSectionBounds.boundingBoxes[bp];\n\n    let maxRow = 0;  // Maximum row coordinate across all sections\n    let maxCol = 0;  // Maximum column coordinate across all sections\n\n    // Examine each section's bounding box to find overall extents\n    for (const sectionId of sections) {\n      const boundBox: GridBox = localGridBoxesPerBp[sectionId as sectionIDs];\n\n      // Calculate the far edges of this bounding box\n      const boxMaxRow = boundBox.origin.y + boundBox.diagonal.y;  // Bottom edge\n      const boxMaxCol = boundBox.origin.x + boundBox.diagonal.x;  // Right edge\n\n      // Update global maximums\n      if (boxMaxRow > maxRow) {\n        maxRow = boxMaxRow;\n      }\n      if (boxMaxCol > maxCol) {\n        maxCol = boxMaxCol;\n      }\n    }\n\n    // Set grid dimensions (subtract 1 because CSS Grid is 1-indexed)\n    // Ensure minimum dimensions of 1x1\n    LayoutAbsolute.gridDimensions.rows[bp] = Math.max(1, maxRow - 1);\n    LayoutAbsolute.gridDimensions.columns[bp] = Math.max(1, maxCol - 1);\n  });\n\n  // PHASE 6: Convert all box positions to CSS coordinate format\n  // Initialize sections structure to hold CSS coordinates\n  LayoutAbsolute.sections = {} as Record<sectionIDs, BoxesCoordinates<blockIDs>>;\n\n  // Track minimum coordinates across all breakpoints to ensure positivity\n  // CSS Grid requires all coordinates to be ≥1\n  let minCoordinate: BPs<Coordinate> = {\n    xs: { x: Infinity, y: Infinity },\n    sm: { x: Infinity, y: Infinity },\n    md: { x: Infinity, y: Infinity },\n    lg: { x: Infinity, y: Infinity },\n    xl: { x: Infinity, y: Infinity },\n  };\n\n  // Process each section to convert box coordinates to CSS format\n  for (const sectionId of sections) {\n    // Initialize coordinate structure for this section\n    let crd: BoxesCoordinates<blockIDs> = {} as BoxesCoordinates<blockIDs>;\n    crd.coordinates = {} as BPs<Partial<Record<blockIDs, CSSCoordinates>>>;\n\n    // Process each breakpoint\n    BREAKPOINTS.forEach((bp) => {\n      crd.coordinates[bp] = {} as Partial<Record<blockIDs, CSSCoordinates>>;\n\n      // Get all boxes for this section at this breakpoint\n      let boxesatBp: Partial<Record<blockIDs, GridBox>> =\n        layoutSectionBounds.sections[sectionId][bp];\n\n      if (!boxesatBp) {\n        return;\n      }\n      \n      // Convert each box to CSS coordinates and track minimums\n      for (const boxId in boxesatBp) {\n        const box = boxesatBp[boxId as blockIDs];\n        if (!box) {\n          continue;\n        }\n\n        // Convert GridBox to CSS grid coordinates\n        let coord: CSSCoordinates = getCSSCoordinates(box);\n        crd.coordinates[bp][boxId as blockIDs] = coord;\n\n        // Track minimum coordinates to detect negative values\n        if (coord.gridColumnStart < minCoordinate[bp].x) {\n          minCoordinate[bp].x = coord.gridColumnStart;\n        }\n\n        if (coord.gridRowStart < minCoordinate[bp].y) {\n          minCoordinate[bp].y = coord.gridRowStart;\n        }\n      }\n    });\n\n    // Store the coordinate data for this section\n    LayoutAbsolute.sections[sectionId] = crd;\n  }\n\n  // PHASE 7: Normalize coordinates to ensure all values are ≥1\n  // CSS Grid specification requires positive coordinates starting from 1\n  BREAKPOINTS.forEach((bp) => {\n    // Handle empty grid case\n    if (minCoordinate[bp].x === Infinity && minCoordinate[bp].y === Infinity) {\n      diagnostics.push(\n        makeWarning(\n          'layoutSectionBtoAbsolute',\n          GRID_ERROR_CODE.EMPTY_GRID,\n          `Empty grid at breakpoint ${bp}. Setting minimal dimensions`,\n        ),\n      );\n      // Set minimum valid grid dimensions\n      LayoutAbsolute.gridDimensions.columns[bp] = 1;\n      LayoutAbsolute.gridDimensions.rows[bp] = 1;\n      return;\n    }\n    \n    // Calculate displacement needed to make all coordinates ≥1\n    let dx = 0;  // Horizontal displacement\n    let dy = 0;  // Vertical displacement\n\n    // Calculate displacement needed to normalize negative coordinates\n    if (minCoordinate[bp].x < 1) {\n      dx = 1 - minCoordinate[bp].x;  // Amount to shift right\n    }\n    if (minCoordinate[bp].y < 1) {\n      dy = 1 - minCoordinate[bp].y;  // Amount to shift down\n    }\n\n    // Skip normalization if no displacement needed\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n\n    // Adjust grid dimensions to account for the displacement\n    LayoutAbsolute.gridDimensions.columns[bp] += dx;\n    LayoutAbsolute.gridDimensions.rows[bp] += dy;\n\n    // Log the normalization for diagnostic purposes\n    diagnostics.push(\n      makeWarning(\n        'layoutSectionBtoAbsolute',\n        GRID_ERROR_CODE.GRID_NORMALIZED_TO_POSITIVE_LINES,\n        `Grid normalized to positive values at bp ${bp}`,\n      ),\n    );\n\n    // Apply displacement to all coordinates\n    for (const sectionId of sections) {\n      let coordinates: Partial<Record<blockIDs, CSSCoordinates>> =\n        LayoutAbsolute.sections[sectionId].coordinates[bp];\n\n      if (!coordinates) {\n        continue;\n      }\n      \n      // Shift each box's coordinates by the calculated displacement\n      for (const boxId in coordinates) {\n        let coordinate = coordinates[boxId];\n\n        if (!coordinate) {\n          continue;\n        }\n\n        // Apply horizontal and vertical shifts to all coordinate values\n        coordinate.gridColumnEnd += dx;    // Right edge\n        coordinate.gridColumnStart += dx;  // Left edge\n        coordinate.gridRowStart += dy;     // Top edge\n        coordinate.gridRowEnd += dy;       // Bottom edge\n      }\n    }\n  });\n\n  // Return the complete layout with absolute CSS coordinates\n  return LayoutAbsolute;\n}\n\n/**\n * Convert a GridBox to CSS Grid coordinates\n * \n * Transforms a GridBox (with origin and diagonal) into CSS Grid coordinate format\n * (with explicit start and end positions for rows and columns).\n * \n * @param box - GridBox with origin point and diagonal vector\n * @returns CSS coordinates with start/end positions for grid placement\n */\nfunction getCSSCoordinates(box: GridBox): CSSCoordinates {\n  return {\n    // Column positioning: start at origin X, end at origin X + width\n    gridColumnStart: box.origin.x,\n    gridColumnEnd: box.origin.x + box.diagonal.x,\n\n    // Row positioning: start at origin Y, end at origin Y + height\n    gridRowStart: box.origin.y,\n    gridRowEnd: box.origin.y + box.diagonal.y,\n  };\n}\n","/**\n * Layout Section To Bounds\n * \n * This module converts layout sections with local positioning to sections with bounding boxes.\n * It calculates the minimum bounding rectangle that contains all boxes within each section\n * across different breakpoints (responsive design sizes).\n */\n\n// Type definitions for grid boxes and their positioning\nimport { GridBox } from \"../box/gridBoxTypes\";\nimport { makeGridBox } from \"../box/gridBoxUtils\";\n\n// Layout types for sections and their breakpoint-specific configurations\nimport {\n  BPSGridBoxes,\n  LayoutSectionBounds,\n  LayoutSectionLocal,\n} from \"../boxLayout/boxLayoutTypes\";\n\n// Responsive breakpoint definitions (xs, sm, md, lg, xl)\nimport { BREAKPOINTS } from \"../breakpoints\";\n\n// Error handling and diagnostic utilities\nimport { DiagnosticEntry, GRID_ERROR_CODE, makeError } from \"../gridErrorShape\";\n\n// Template identifiers for sections and blocks\nimport { SectionIDs, BlocksIDs } from \"../templates\";\n\n/**\n * Extract valid section IDs from a partial record of sections\n * \n * Filters out null/undefined sections and returns only the keys\n * of sections that have actual content.\n * \n * @param sections - Partial record of sections with potential null/undefined values\n * @returns Array of valid section IDs that have non-null content\n */\nfunction layoutSectionKeys<sectionIDs extends SectionIDs>(\n  sections: Partial<Record<sectionIDs, unknown>>\n): sectionIDs[] {\n  return Object.keys(sections).filter(\n    (k) => sections[k as sectionIDs] != null\n  ) as Array<sectionIDs>;\n}\n\n/**\n * Convert layout sections with local positioning to sections with bounding boxes\n * \n * This function calculates the minimum bounding rectangle (bounds) that contains all boxes\n * within each section across different responsive breakpoints. It processes each section\n * and breakpoint combination to find the smallest rectangle that encompasses all boxes.\n * \n * @template sectionIDs - Type representing the available section identifiers\n * @template blockIDs - Type representing the available block/box identifiers\n * @param layoutSectionLocal - Layout with sections containing boxes positioned locally\n * @param diagnostics - Array to collect any errors or warnings during processing\n * @returns Layout with calculated bounding boxes for each section at each breakpoint\n */\nexport function layoutSectionToBounds<\n  sectionIDs extends SectionIDs,\n  blockIDs extends BlocksIDs\n>(\n  layoutSectionLocal: LayoutSectionLocal<sectionIDs, blockIDs>,\n  diagnostics: DiagnosticEntry[]\n): LayoutSectionBounds<sectionIDs, blockIDs> {\n  // Initialize the result object that will contain bounding boxes for each section\n  let layoutSectionBounds: LayoutSectionBounds<sectionIDs, blockIDs> =\n    {} as LayoutSectionBounds<sectionIDs, blockIDs>;\n\n  // Copy the original sections data (contains the actual box configurations)\n  layoutSectionBounds.sections = layoutSectionLocal.sections;\n\n  // Initialize bounding boxes structure for all responsive breakpoints\n  // Each breakpoint will have a record of section ID -> bounding box\n  layoutSectionBounds.boundingBoxes = {\n    xs: {} as Record<sectionIDs, GridBox>,\n    sm: {} as Record<sectionIDs, GridBox>,\n    md: {} as Record<sectionIDs, GridBox>,\n    lg: {} as Record<sectionIDs, GridBox>,\n    xl: {} as Record<sectionIDs, GridBox>,\n  };\n\n  // Copy transformation settings from the original layout\n  layoutSectionBounds.transformations = layoutSectionLocal.transformations;\n\n  // Extract valid section IDs (filters out null/undefined sections)\n  const sectionIds = layoutSectionKeys(layoutSectionLocal.sections);\n\n  // Process each responsive breakpoint (xs, sm, md, lg, xl)\n  BREAKPOINTS.forEach((bp) => {\n    // Calculate bounding box for each section at this breakpoint\n    for (const sectionId of sectionIds) {\n      let boundPerSection: GridBox;\n\n      // Initialize bounds tracking variables\n      // Start with extreme values so first box will set initial bounds\n      let minX = Infinity;  // Leftmost edge\n      let minY = Infinity;  // Topmost edge\n      let maxX = -Infinity; // Rightmost edge\n      let maxY = -Infinity; // Bottommost edge\n\n      // Get all grid boxes for this section\n      let gridBoxes: BPSGridBoxes<blockIDs> =\n        layoutSectionLocal.sections[sectionId];\n\n      // Get boxes specific to current breakpoint\n      const boxesAtBp = gridBoxes[bp];\n\n      // Track whether we found any boxes (for error handling)\n      let foundAnyBox = false;\n\n      // Iterate through all boxes in this section at this breakpoint\n      for (const boxId in boxesAtBp) {\n        const box = boxesAtBp[boxId];\n\n        // Skip null/undefined boxes\n        if (!box) {\n          continue;\n        }\n\n        // Update bounding box coordinates\n        // box.origin = top-left corner, box.diagonal = width/height as vector\n        minX = Math.min(minX, box.origin.x);                    // Left edge\n        maxX = Math.max(maxX, box.origin.x + box.diagonal.x);   // Right edge (origin + width)\n        minY = Math.min(minY, box.origin.y);                    // Top edge\n        maxY = Math.max(maxY, box.origin.y + box.diagonal.y);   // Bottom edge (origin + height)\n\n        foundAnyBox = true;\n      }\n\n      // Handle case where no boxes were found in this section at this breakpoint\n      if (!foundAnyBox) {\n        // Log diagnostic error for missing boxes\n        diagnostics.push(\n          makeError(\n            \"layoutSectionToBounds\",\n            GRID_ERROR_CODE.MISSING_BOX,\n            `No boxes found for section ${sectionId} at breakpoint ${bp}. Returning empty bounding box.`\n          )\n        );\n        // Create an empty bounding box as fallback\n        boundPerSection = makeGridBox({ x: 0, y: 0 }, { x: 0, y: 0 });\n        layoutSectionBounds.boundingBoxes[bp][sectionId] = boundPerSection;\n        continue;\n      }\n\n      // Create the bounding box from calculated min/max coordinates\n      boundPerSection = makeGridBox(\n        {\n          x: minX,  // Top-left corner X coordinate\n          y: minY,  // Top-left corner Y coordinate\n        },\n        {\n          x: maxX - minX,  // Width (right edge - left edge)\n          y: maxY - minY,  // Height (bottom edge - top edge)\n        }\n      );\n\n      // Store the calculated bounding box for this section at this breakpoint\n      layoutSectionBounds.boundingBoxes[bp][sectionId] = boundPerSection;\n    }\n  });\n\n  // Return the complete layout with calculated bounding boxes\n  return layoutSectionBounds;\n}\n","/**\n * @fileoverview Layout transformation to section-local coordinate conversion.\n * Converts layout transformations into section-local coordinates and applies box transformations.\n * Handles the transition from layout-level coordinates to section-specific positioning.\n * @module LayoutTxToSectionLocal\n */\n\nimport { GridBox } from \"../box/gridBoxTypes\";\nimport { LayoutWithTx, LayoutSectionLocal, BPSGridBoxes, BoxTransformations } from \"../boxLayout\";\nimport { DefaultBoxTransformations } from \"../boxTransformations\";\nimport { BREAKPOINTS, BPs } from \"../breakpoints\";\nimport { DiagnosticEntry } from \"../gridErrorShape\";\nimport { SectionIDs, BlocksIDs } from \"../templates\";\nimport { transformBoxMove } from \"./transformBoxMove\";\n\n/**\n * Extracts section keys that contain actual data from a layout with transformations.\n * Filters out null or undefined sections to prevent processing of empty sections.\n * This ensures that only sections with content are included in the transformation pipeline.\n * \n * @template sectionIDs - The section ID type constrained to valid SectionIDs\n * @param sections - Partial record of sections that may contain null/undefined values\n * @returns Array of section IDs that have actual content\n * \n * @example\n * ```typescript\n * const sections = { header: {...}, main: null, footer: {...} };\n * const keys = layoutTxSectionKeys(sections);\n * // Returns: ['header', 'footer']\n * ```\n */\n\n\nfunction layoutTxSectionKeys<sectionIDs extends SectionIDs>(\n  sections: Partial<Record<sectionIDs, unknown>>,\n): sectionIDs[] {\n  return Object.keys(sections).filter(\n    (k) => sections[k as sectionIDs] != null,\n  ) as Array<sectionIDs>;\n}\n\n/**\n * Converts a layout with transformations into section-local coordinate space.\n * This function processes the transformation pipeline by applying section-level box transformations\n * while maintaining the layout structure in local coordinates relative to each section.\n * \n * Processing pipeline:\n * 1. Initializes default box transformations for movement operations\n * 2. Creates section-local layout structure with grid boxes from the layout transformation\n * 3. Copies grid box data for each breakpoint to maintain positioning information\n * 4. Applies section-specific transformations using the box movement system\n * 5. Returns the final layout in section-local coordinate space\n * \n * Key behaviors:\n * - Preserves layout-level transformations in the output structure\n * - Converts grid boxes from layout coordinates to section-relative coordinates\n * - Applies transformation functions (stacking, alignment, etc.) within each section\n * - Collects diagnostic information for any transformation issues\n * - Handles missing transformations gracefully by skipping affected sections\n * \n * @template sectionIDs - The section identifier types for this layout\n * @template blockIDs - The block identifier types for this layout\n * @param layoutTx - Layout with transformations containing positioned grid boxes\n * @param diagnostics - Array to collect diagnostic information and errors during processing\n * @returns Layout in section-local coordinates with applied transformations\n * \n * @example\n * ```typescript\n * const layoutWithTx: LayoutWithTx<'header' | 'main', 'block_1' | 'block_2'> = {\n *   sections: {\n *     header: {\n *       gridBoxes: { xs: { block_1: gridBox1 }, md: { block_1: gridBox1 } },\n *       transformations: { xs: [{ stackHorizontally: {} }] }\n *     }\n *   },\n *   transformations: { xs: [{ stackVertically: {} }] }\n * };\n * \n * const diagnostics: DiagnosticEntry[] = [];\n * const sectionLocal = layoutTxToSectionLocal(layoutWithTx, diagnostics);\n * \n * // Result contains section-relative positioned boxes with applied transformations\n * // sectionLocal.sections[sectionId][breakpoint][blockId] = transformed GridBox\n * ```\n */\nexport function layoutTxToSectionLocal<sectionIDs extends SectionIDs, blockIDs extends BlocksIDs>(\n  layoutTx: LayoutWithTx<sectionIDs, blockIDs>,\n  diagnostics: DiagnosticEntry[],\n): LayoutSectionLocal<sectionIDs, blockIDs> {\n  // Initialize default box transformations for movement operations\n  const defaultBoxTransformations = DefaultBoxTransformations();\n\n  // Initialize the layoutSectionLocal structure\n  let layoutSectionLocal: LayoutSectionLocal<sectionIDs, blockIDs> = {\n    sections: {} as Record<sectionIDs, BPSGridBoxes<blockIDs>>,\n    transformations: layoutTx.transformations\n      ? layoutTx.transformations\n      : ({} as BoxTransformations<sectionIDs>),\n  };\n\n  const sectionsKeys = layoutTxSectionKeys(layoutTx.sections);\n\n  // Initialize the layoutSectionLocal structure with the boxes from LayoutWithTx\n  for (const sectionId of sectionsKeys) {\n    layoutSectionLocal.sections[sectionId] = {} as BPSGridBoxes<blockIDs>;\n\n    BREAKPOINTS.forEach((bp) => {\n      layoutSectionLocal.sections[sectionId][bp] = layoutTx.sections[sectionId].gridBoxes[bp];\n    });\n  }\n\n  // Apply transformations if any are defined\n  for (const sectionId of sectionsKeys) {\n    // Evaluate transformations for this section\n    const transformations: BoxTransformations<blockIDs> | undefined =\n      layoutTx.sections[sectionId].transformations;\n\n    if (!transformations) {\n      continue; // No transformations to apply\n    }\n\n    // Get the local grid boxes for each breakpoint\n    let localGridBoxesPerBp: BPs<Partial<Record<blockIDs, GridBox>>> =\n      layoutSectionLocal.sections[sectionId];\n\n    // Apply box movement transformations\n    transformBoxMove<blockIDs>(\n      defaultBoxTransformations,\n      transformations,\n      localGridBoxesPerBp,\n      diagnostics,\n    );\n  }\n\n  return layoutSectionLocal;\n}\n\n// Working examples demonstrating the layoutTxToSectionLocal functionality\n\n// Example 1: layoutTxSectionKeys usage\nconst sectionsExample = { \n  header: { gridBoxes: {}, transformations: {} }, \n  main: null, \n  footer: { gridBoxes: {}, transformations: {} } \n};\nconst keys = layoutTxSectionKeys(sectionsExample);\n// Returns: ['header', 'footer']\n\n// Example 2: Complete layoutTxToSectionLocal usage\nconst layoutWithTxExample: LayoutWithTx<'header' | 'main', 'block_1' | 'block_2'> = {\n  sections: {\n    header: {\n      gridBoxes: { \n        xs: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 100, y: 50 }, _normalized: \"GridBox\" } \n        },\n        md: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 200, y: 50 }, _normalized: \"GridBox\" } \n        },\n        lg: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 300, y: 50 }, _normalized: \"GridBox\" } \n        },\n        sm: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 150, y: 50 }, _normalized: \"GridBox\" } \n        },\n        xl: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 400, y: 50 }, _normalized: \"GridBox\" } \n        },\n      } as BPSGridBoxes<'block_1' | 'block_2'>,\n      transformations: { \n        xs: [{ stackHorizontally: {} }],\n        md: [{ stackHorizontally: { gap: 20 } }],\n        lg  : [{ stackHorizontally: { gap: 30 } }],\n        sm: [{ stackHorizontally: { gap: 15 } }],\n        xl: [{ stackHorizontally: { gap: 40 } }]\n      }\n    },\n    main: {\n      gridBoxes: {\n       xs: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 100, y: 50 }, _normalized: \"GridBox\" } \n        },\n        md: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 200, y: 50 }, _normalized: \"GridBox\" } \n        },\n        lg: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 300, y: 50 }, _normalized: \"GridBox\" } \n        },\n        sm: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 150, y: 50 }, _normalized: \"GridBox\" } \n        },\n        xl: { \n          block_1: { origin: { x: 0, y: 0 }, diagonal: { x: 400, y: 50 }, _normalized: \"GridBox\" } \n        },\n      } as BPSGridBoxes<'block_1' | 'block_2'>,\n      transformations: {\n         xs: [{ stackHorizontally: {} }],\n        md: [{ stackHorizontally: { gap: 20 } }],\n        lg  : [{ stackHorizontally: { gap: 30 } }],\n        sm: [{ stackHorizontally: { gap: 15 } }],\n        xl: [{ stackHorizontally: { gap: 40 } }]\n      }\n    }\n  },\n  transformations: { \n    xs: [{ stackHorizontally: {} }],\n        md: [{ stackHorizontally: { gap: 20 } }],\n        lg  : [{ stackHorizontally: { gap: 30 } }],\n        sm: [{ stackHorizontally: { gap: 15 } }],\n        xl: [{ stackHorizontally: { gap: 40 } }]\n  }\n};\n\nconst diagnosticsExample: DiagnosticEntry[] = [];\nconst sectionLocalExample = layoutTxToSectionLocal(layoutWithTxExample, diagnosticsExample);\n\n// Result contains section-relative positioned boxes with applied transformations\n// sectionLocalExample.sections[sectionId][breakpoint][blockId] = transformed GridBox\n\n// Check for any transformation issues\nif (diagnosticsExample.length > 0) {\n  console.log('Transformation issues:', diagnosticsExample);\n}\n\n// Example 3: Accessing the results\nconst headerXsBlocks = sectionLocalExample.sections.header.xs;\nconst mainMdBlocks = sectionLocalExample.sections.main.md;\nconst layoutLevelTransforms = sectionLocalExample.transformations;\n","/**\n * CSS Layout Generator\n * \n * This module orchestrates the complete transformation pipeline from layout definitions\n * with transformations to final CSS Grid coordinates. It coordinates multiple transformation\n * phases and provides optional overlap detection and validation.\n * \n * Main pipeline:\n * 1. Convert layout transformations to local section coordinates\n * 2. Calculate bounding boxes for each section\n * 3. Transform to absolute CSS Grid coordinates\n * 4. Optionally validate for overlapping elements\n * \n * Features:\n * - Multi-breakpoint responsive layout support\n * - Configurable overlap detection (allow/warn/error)\n * - Comprehensive diagnostic reporting\n * - Type-safe section and block ID handling\n */\n\n// Layout type definitions for different transformation stages\nimport {\n  LayoutAbsolute,           // Final layout with absolute CSS coordinates\n  LayoutWithTx,             // Input layout with transformation configurations\n} from \"../boxLayout/boxLayoutTypes\";\n\n// Responsive breakpoint definitions\nimport { BREAKPOINTS } from \"../breakpoints\";\n\n// Error handling and diagnostic utilities\nimport {\n  DiagnosticEntry,\n  GRID_ERROR_CODE,\n  makeError,\n  makeWarning,\n} from \"../gridErrorShape\";\n\n// CSS Grid coordinate type definitions\nimport { CSSCoordinates } from \"../gridNodeTypes\";\n\n// Template identifiers for sections and blocks\nimport { BlocksIDs, SectionIDs } from \"../templates\";\n\n// Transformation pipeline functions\nimport { layoutSectionBtoAbsolute } from \"./layoutSectionBtoAbsolute\";\nimport { layoutSectionToBounds } from \"./layoutSectionToBounds\";\nimport { layoutTxToSectionLocal } from \"./layoutTxToSectionLocal\";\n\n/**\n * Configuration for grid validation and diagnostic behavior\n * \n * @property overlapPolicy - How to handle overlapping boxes:\n *   - \"allow\": No overlap checking (default)\n *   - \"warn\": Check and report warnings for overlaps\n *   - \"error\": Check and report errors for overlaps\n * @property breakpoints - Which breakpoints to validate (defaults to all)\n */\ntype GridDiagnostic = {\n  overlapPolicy?: \"allow\" | \"warn\" | \"error\";\n  breakpoints?: readonly (typeof BREAKPOINTS)[number][];\n};\n\n/**\n * Props for the main CSSLayout function\n * \n * @template L - Layout type extending LayoutWithTx\n * @property layoutWithTx - Input layout with transformation configurations\n * @property diagnostics - Array to collect errors and warnings\n * @property gridDiagnostic - Optional validation configuration\n */\ntype CSSLayoutProps<sectionIDs extends SectionIDs, blockIDs extends BlocksIDs> = {\n  layoutWithTx: LayoutWithTx<sectionIDs, blockIDs>;\n  diagnostics: DiagnosticEntry[];\n  gridDiagnostic?: GridDiagnostic;\n};\n\n/**\n * Main CSS Layout transformation function\n * \n * Orchestrates the complete pipeline to transform a layout with transformations\n * into final CSS Grid coordinates. This is the primary entry point for the\n * layout transformation system.\n * \n * Transformation Pipeline:\n * 1. layoutTxToSectionLocal - Applies transformations and converts to local coordinates\n * 2. layoutSectionToBounds - Calculates bounding boxes for each section\n * 3. layoutSectionBtoAbsolute - Converts to absolute CSS Grid coordinates\n * 4. checkSectionsOverlap - Optionally validates for overlapping elements\n * \n * @template L - Layout type that extends LayoutWithTx\n * @param props - Configuration object containing layout, diagnostics, and validation options\n * @returns Layout with absolute CSS Grid coordinates for all sections and boxes\n */\nexport function CSSLayout<sectionIDs extends SectionIDs, blockIDs extends BlocksIDs >({\n  layoutWithTx,\n  diagnostics,\n  gridDiagnostic = { overlapPolicy: \"allow\", breakpoints: BREAKPOINTS },\n}: CSSLayoutProps<sectionIDs, blockIDs  >): LayoutAbsolute<\n  sectionIDs,\n  blockIDs\n> {\n  // Step 1: Apply transformations and convert to local section coordinates\n  // This resolves all transformation rules and positions boxes within sections\n  const layoutSectionLocal = layoutTxToSectionLocal(layoutWithTx, diagnostics);\n\n  // Step 2: Calculate bounding boxes for each section across all breakpoints\n  // This finds the minimum rectangle that contains all boxes in each section\n  const layoutSecBonds = layoutSectionToBounds(layoutSectionLocal, diagnostics);\n\n  // Step 3: Convert to absolute CSS Grid coordinates\n  // This positions sections absolutely and ensures all coordinates are valid for CSS Grid\n  const layoutSecAbs = layoutSectionBtoAbsolute(layoutSecBonds, diagnostics);\n\n  // Extract diagnostic configuration with defaults\n  const overlapPolicy = gridDiagnostic.overlapPolicy || \"allow\";\n  const breakpoints = gridDiagnostic.breakpoints || BREAKPOINTS;\n\n  // Step 4: Optional overlap detection and validation\n  // Check for overlapping boxes if overlap policy is not \"allow\"\n  if (overlapPolicy !== \"allow\") {\n    checkSectionsOverlap<sectionIDs, blockIDs>(\n      layoutSecAbs,\n      diagnostics,\n      overlapPolicy,\n      breakpoints\n    );\n  }\n\n  return layoutSecAbs;\n}\n\n/**\n * Rectangle definition for overlap detection\n * Represents the bounds of a box in CSS Grid coordinates\n */\ntype OverlapRect = {\n  colStart: number;  // Left edge (grid column start)\n  colEnd: number;    // Right edge (grid column end)\n  rowStart: number;  // Top edge (grid row start)\n  rowEnd: number;    // Bottom edge (grid row end)\n};\n\n/**\n * Reference to a specific box for overlap reporting\n * Contains all information needed to identify a box in overlap scenarios\n */\ntype OverlapRef<sectionIDs extends SectionIDs, blockIDs extends BlocksIDs> = {\n  sectionId: sectionIDs;  // Which section contains this box\n  boxId: blockIDs;        // The specific box identifier\n  rect: OverlapRect;      // The box's rectangular bounds\n};\n\n/**\n * Complete overlap detection result\n * Contains all details about two overlapping boxes\n */\ntype OverlapDetails<\n  sectionIDs extends SectionIDs,\n  blockIDs extends BlocksIDs\n> = {\n  bp: (typeof BREAKPOINTS)[number];        // Which breakpoint the overlap occurs at\n  a: OverlapRef<sectionIDs, blockIDs>;     // First overlapping box\n  b: OverlapRef<sectionIDs, blockIDs>;     // Second overlapping box\n  pairKey: string;                         // Unique identifier for this overlap pair\n};\n\n/**\n * Box with metadata for overlap detection processing\n * Combines box coordinates with identification information\n */\ntype BoxWithMeta<sectionIDs extends SectionIDs, blockIDs extends BlocksIDs> = {\n  id: string;                              // Composite unique identifier\n  bp: (typeof BREAKPOINTS)[number];       // Breakpoint this box exists at\n  sectionId: sectionIDs;                  // Parent section identifier\n  boxId: blockIDs;                        // Box identifier within section\n  coords: CSSCoordinates;                 // Actual CSS Grid coordinates\n};\n\n/**\n * Extract keys from a complete Record type\n * Type-safe utility for getting object keys when all properties are present\n * \n * @param obj - Record with all keys present\n * @returns Array of keys with correct typing\n */\n\nfunction recordKeys<K extends string, V>(obj: Record<K, V>): K[] {\n  return Object.keys(obj) as K[];\n}\n\n/**\n * Extract keys from a Partial Record type\n * Type-safe utility for getting object keys when some properties may be undefined\n * \n * @param obj - Partial record with potentially missing keys\n * @returns Array of present keys with correct typing\n */\nfunction partialRecordKeys<K extends string, V>(\n  obj: Partial<Record<K, V>>\n): K[] {\n  return Object.keys(obj) as K[];\n}\n\n/**\n * Check if two CSS Grid coordinate rectangles overlap\n * \n * Uses the standard rectangle overlap algorithm: two rectangles overlap\n * if they overlap in both the X (column) and Y (row) dimensions.\n * \n * For rectangles to NOT overlap, at least one of these must be true:\n * - a's left edge is at or past b's right edge\n * - b's left edge is at or past a's right edge  \n * - a's top edge is at or past b's bottom edge\n * - b's top edge is at or past a's bottom edge\n * \n * @param a - First rectangle's CSS coordinates\n * @param b - Second rectangle's CSS coordinates\n * @returns true if rectangles overlap, false otherwise\n */\nfunction overlaps(a: CSSCoordinates, b: CSSCoordinates): boolean {\n  return (\n    a.gridColumnStart < b.gridColumnEnd &&    // a's left < b's right\n    b.gridColumnStart < a.gridColumnEnd &&    // b's left < a's right\n    a.gridRowStart < b.gridRowEnd &&          // a's top < b's bottom\n    b.gridRowStart < a.gridRowEnd             // b's top < a's bottom\n  );\n}\n\n/**\n * Check for overlapping boxes across all sections and report violations\n * \n * This function performs comprehensive overlap detection across the entire layout,\n * checking all boxes against each other within each breakpoint. It generates\n * detailed diagnostic reports for any overlaps found.\n * \n * Algorithm:\n * 1. Flatten all boxes from all sections into a single list per breakpoint\n * 2. Compare every box against every other box (O(n²) complexity)\n * 3. For each overlap, generate detailed diagnostic information\n * 4. Add warnings or errors to diagnostics based on overlap policy\n * \n * @template sectionIDs - Section identifier type\n * @template blockIDs - Block identifier type\n * @param layoutAbsolute - Layout with final absolute CSS coordinates\n * @param diagnostics - Array to add overlap reports to\n * @param overlapPolicy - Whether to generate warnings or errors for overlaps\n * @param breakpoints - Which breakpoints to check for overlaps\n */\nexport function checkSectionsOverlap<\n  sectionIDs extends SectionIDs,\n  blockIDs extends BlocksIDs\n>(\n  layoutAbsolute: LayoutAbsolute<sectionIDs, blockIDs>,\n  diagnostics: DiagnosticEntry[],\n  overlapPolicy: \"warn\" | \"error\",\n  breakpoints: readonly (typeof BREAKPOINTS)[number][]\n) {\n  // Get all section IDs for iteration\n  const sectionIds = recordKeys(layoutAbsolute.sections);\n\n  // Process each breakpoint separately\n  for (const bp of breakpoints) {\n    // Collect all boxes at this breakpoint into a flat list for comparison\n    const boxesByBp: BoxWithMeta<sectionIDs, blockIDs>[] = [];\n\n    // Flatten all boxes from all sections\n    for (const sectionId of sectionIds) {\n      const sectionBoxes = layoutAbsolute.sections[sectionId].coordinates[bp];\n      if (!sectionBoxes) continue;\n\n      const boxIds = partialRecordKeys(sectionBoxes);\n\n      // Add each box to the flat list with metadata\n      for (const boxId of boxIds) {\n        const crd = sectionBoxes[boxId];\n        if (!crd) continue;\n\n        boxesByBp.push({\n          id: `${bp}::${sectionId}::${boxId}`,  // Unique composite identifier\n          bp,\n          sectionId,\n          boxId,\n          coords: crd,\n        });\n      }\n    }\n\n    // Compare every box against every other box (pairwise comparison)\n    for (let i = 0; i < boxesByBp.length; i++) {\n      const a = boxesByBp[i];\n\n      // Only compare with boxes that come after in the list to avoid duplicates\n      for (let j = i + 1; j < boxesByBp.length; j++) {\n        const b = boxesByBp[j];\n\n        // Skip if boxes don't overlap\n        if (!overlaps(a.coords, b.coords)) continue;\n\n        // Create detailed overlap information for diagnostic reporting\n        const details: OverlapDetails<sectionIDs, blockIDs> = {\n          bp,\n          a: {\n            sectionId: a.sectionId,\n            boxId: a.boxId,\n            rect: {\n              colStart: a.coords.gridColumnStart,\n              colEnd: a.coords.gridColumnEnd,\n              rowStart: a.coords.gridRowStart,\n              rowEnd: a.coords.gridRowEnd,\n            },\n          },\n          b: {\n            sectionId: b.sectionId,\n            boxId: b.boxId,\n            rect: {\n              colStart: b.coords.gridColumnStart,\n              colEnd: b.coords.gridColumnEnd,\n              rowStart: b.coords.gridRowStart,\n              rowEnd: b.coords.gridRowEnd,\n            },\n          },\n          pairKey: `${a.id}__${b.id}`,  // Unique pair identifier\n        };\n\n        const message = `Boxes ${a.id} and ${b.id} are overlapping.`;\n\n        // Add warning or error to diagnostics based on policy\n        diagnostics.push(\n          overlapPolicy === \"warn\"\n            ? makeWarning(\n              \"CSSLayout\",\n              GRID_ERROR_CODE.OVERLAP_NOT_ALLOWED,\n              message,\n              {\n                details,\n              }\n            )\n            : makeError(\n              \"CSSLayout\",\n              GRID_ERROR_CODE.OVERLAP_NOT_ALLOWED,\n              message,\n              {\n                details,\n              }\n            )\n        );\n      }\n    }\n  }\n}\n","/**\n * @fileoverview Default layout theme implementation for CSS Grid layout system.\n * Provides a complete, production-ready theme with sensible defaults for all layout scenarios.\n * This theme serves as both a working implementation and a reference for creating custom themes.\n * @module DefaultLayoutTheme\n */\n\nimport { GridBox } from \"../box/gridBoxTypes\";\nimport { makeGridBox } from \"../box/gridBoxUtils\";\nimport {\n\n  BoxSpan,\n  BoxTransformations,\n  Layout,\n\n} from \"../boxLayout/boxLayoutTypes\";\nimport { BREAKPOINTS } from \"../breakpoints\";\nimport { getOrigin } from \"../geometry\";\nimport { GridOptions } from \"../gridOptionsTypes\";\nimport { GridNodeViewOptions } from \"../nodeViewOptions\";\nimport { BlocksIDs, NodeID, SectionIDs } from \"../templates\";\n\nimport { ThemeForLayout } from \"./layoutThemeTypes\";\n\n/**\n * Good boring defaults for CSS Grid items.\n * - minWidth0/minHeight0 prevent overflow caused by min-size:auto\n * - stretch fills the grid area by default\n */\n\nexport const DEFAULT_GRID_NODE_VIEW_OPTIONS = {\n  minWidth0: true,\n  minHeight0: true,\n  justifySelf: \"stretch\",\n  alignSelf: \"stretch\",\n  pointerEvents: \"auto\",\n  dataAttrs: {},\n  aria: {},\n  visibility: \"visible\",\n} as const satisfies Required<\n  Pick<\n    GridNodeViewOptions,\n    | \"minWidth0\"\n    | \"minHeight0\"\n    | \"justifySelf\"\n    | \"alignSelf\"\n    | \"pointerEvents\"\n    | \"dataAttrs\"\n    | \"aria\"\n    | \"visibility\"\n  >\n>;\n/**\n * Resolves grid node view options by merging user-provided options with sensible defaults.\n * This function ensures all required properties are present while allowing selective overrides.\n * \n * Key behaviors:\n * - Shallow merging prevents deep object mutation issues\n * - Always provides complete objects for dataAttrs and aria to prevent null reference errors\n * - Maintains type safety while avoiding complex generic hierarchies\n * - SSR-safe with predictable default values\n * \n * @param opts - Optional user-provided grid node view options to override defaults\n * @returns Complete GridNodeViewOptions object with all required properties\n * \n * @example\n * ```typescript\n * // Basic usage with no overrides\n * const defaultOptions = resolveGridNodeViewOptions();\n * \n * // Override specific properties\n * const customOptions = resolveGridNodeViewOptions({\n *   justifySelf: 'center',\n *   zIndex: 100,\n *   dataAttrs: { 'data-testid': 'grid-item' }\n * });\n * \n * // Aria attributes are safely merged\n * const accessibleOptions = resolveGridNodeViewOptions({\n *   aria: { role: 'button', label: 'Click me' }\n * });\n * ```\n */\n\nexport function resolveGridNodeViewOptions(opts?: GridNodeViewOptions): {\n  zIndex?: number;\n  minWidth0: boolean;\n  minHeight0: boolean;\n  justifySelf: \"start\" | \"end\" | \"center\" | \"stretch\";\n  alignSelf: \"start\" | \"end\" | \"center\" | \"stretch\";\n  pointerEvents: \"auto\" | \"none\";\n  dataAttrs: Record<string, string>;\n  aria: {\n    role?: string;\n    label?: string;\n    labelledBy?: string;\n    describedBy?: string;\n  };\n  visibility: \"visible\" | \"hidden\" | \"visuallyHidden\";\n} {\n  return {\n    ...DEFAULT_GRID_NODE_VIEW_OPTIONS,\n    ...opts,\n    // ensure these objects are always present even if caller passes undefined\n    dataAttrs: {\n      ...DEFAULT_GRID_NODE_VIEW_OPTIONS.dataAttrs,\n      ...(opts?.dataAttrs ?? {}),\n    },\n    aria: { ...DEFAULT_GRID_NODE_VIEW_OPTIONS.aria, ...(opts?.aria ?? {}) },\n  };\n}\n/**\n * Default CSS Grid container options providing production-ready, boring defaults.\n * These settings create predictable grid behavior that works well for most application layouts.\n * \n * Configuration rationale:\n * - `autoFlow: \"row\"`: Matches natural DOM document flow expectations\n * - `overflow: \"visible\"`: Prevents unexpected clipping; opt-in for containment\n * - `justifyItems/alignItems: \"stretch\"`: Children fill their grid areas by default\n * - `justifyContent/alignContent: \"start\"`: Grid tracks pack from top-left (predictable)\n * - `implicitRowUnits/implicitColumnUnits: 1fr`: Auto-generated tracks use fractional units\n * - `gaps: 0px`: No spacing by default; add intentionally to avoid layout surprises\n * \n * @constant\n * @type {GridOptions}\n * \n * @example\n * ```typescript\n * // Use as base for custom grid configurations\n * const customGridOptions = {\n *   ...DEFAULT_GRID_OPTIONS,\n *   gap: { value: 16, unit: 'px' },\n *   justifyContent: 'center'\n * };\n * \n * // For responsive layouts\n * const responsiveOptions = {\n *   ...DEFAULT_GRID_OPTIONS,\n *   implicitColumnUnits: { value: 250, unit: 'px' } // Fixed column width\n * };\n * ```\n */\n\nexport const DEFAULT_GRID_OPTIONS = {\n  implicitRowUnits: { value: 1, unit: \"fr\" },\n  implicitColumnUnits: { value: 1, unit: \"fr\" },\n\n  overflow: \"visible\",\n  autoFlow: \"row\",\n\n  justifyItems: \"stretch\",\n  alignItems: \"stretch\",\n\n  justifyContent: \"start\",\n  alignContent: \"start\",\n\n  gap: { value: 0, unit: \"px\" },\n  rowGap: { value: 0, unit: \"px\" },\n  columnGap: { value: 0, unit: \"px\" },\n} as const satisfies GridOptions;\n/**\n * Resolves grid options by merging user-provided options with sensible defaults.\n * Uses shallow merging for predictable behavior and optimal performance.\n * \n * Benefits:\n * - Shallow merging avoids deep object mutation concerns\n * - Predictable output regardless of input completeness\n * - SSR-safe with consistent default values\n * - Type-safe partial option overrides\n * \n * @param opts - Optional partial grid options to override defaults\n * @returns Complete GridOptions object with all required properties\n * \n * @example\n * ```typescript\n * // Use defaults\n * const defaultGrid = resolveGridOptions();\n * \n * // Override specific properties\n * const spacedGrid = resolveGridOptions({\n *   gap: { value: 20, unit: 'px' },\n *   justifyContent: 'center'\n * });\n * \n * // Responsive column sizing\n * const responsiveGrid = resolveGridOptions({\n *   implicitColumnUnits: { value: 300, unit: 'px' }\n * });\n * ```\n */\n\nexport function resolveGridOptions(opts?: Partial<GridOptions>): GridOptions {\n  return {\n    ...DEFAULT_GRID_OPTIONS,\n    ...opts,\n  };\n}\n\n/**\n * Default responsive transformations for horizontal layouts (rows).\n * Stacks vertically on mobile, switches to horizontal on larger screens.\n * Ideal for navigation bars, button groups, or horizontal content sections.\n * \n * @constant\n * @type {BoxTransformations<NodeID>}\n */\nexport const DefaultTransformationsResponsiveRows = {\n  xs: [{ stackVertically: {} }],\n  sm: [{ stackHorizontally: {} }],\n  md: [{ stackHorizontally: {} }],\n  lg: [{ stackHorizontally: {} }],\n  xl: [{ stackHorizontally: {} }],\n} as const satisfies BoxTransformations<NodeID>;\n\n/**\n * Default responsive transformations for vertical layouts (columns).\n * Maintains vertical stacking across all breakpoints.\n * Ideal for main content areas, article layouts, or form sections.\n * \n * @constant\n * @type {BoxTransformations<NodeID>}\n */\nexport const DefaultTransformationsResponsiveColumns = {\n  xs: [{ stackVertically: {} }],\n  sm: [{ stackVertically: {} }],\n  md: [{ stackVertically: {} }],\n  lg: [{ stackVertically: {} }],\n  xl: [{ stackVertically: {} }],\n} as const satisfies BoxTransformations<NodeID>;\n\n/**\n * Creates a complete default theme for a given layout type.\n * This function provides a production-ready theme implementation with sensible defaults\n * for all aspects of layout rendering, transformation, and visual presentation.\n * \n * Theme behaviors:\n * - **Box span resolution**: Responsive sizing with full-width on mobile (xs breakpoint)\n * - **Section transformations**: Horizontal stacking for most content (responsive rows)\n * - **Layout transformations**: Vertical section stacking (responsive columns)\n * - **Visual options**: Stretch behavior with overflow prevention\n * - **Grid configuration**: Standard CSS Grid defaults with predictable behavior\n * \n * The theme automatically handles:\n * - Mobile-first responsive design patterns\n * - CSS Grid best practices and common pitfall avoidance\n * - Accessibility-friendly default configurations\n * - SSR-compatible option resolution\n * \n * @template L - The layout type this theme will be applied to\n * @param layout - The layout configuration to create a theme for\n * @returns Complete ThemeForLayout implementation with all required methods and options\n * \n * @example\n * ```typescript\n * const myLayout = {\n *   header: { nav: { spanX: 4, spanY: 1 }, logo: { spanX: 2, spanY: 1 } },\n *   main: { content: { spanX: 6, spanY: 4 } }\n * } as const satisfies Layout;\n * \n * const theme = getDefaultTheme(myLayout);\n * \n * // Use theme methods\n * const gridBox = theme.resolveBoxSpan('header', 'nav', myLayout, { spanX: 4, spanY: 1 }, 'md');\n * const transforms = theme.sectionBoxTransforms('header', myLayout);\n * ```\n */\nexport const getDefaultTheme = <sectionIDS extends SectionIDs, blockIDS extends BlocksIDs>(layout: Layout<sectionIDS, blockIDS>) => {\n  const theme = {\n    resolveBoxSpan: <S extends SectionIDs, B extends BlocksIDs>(\n      section: S,\n      boxId: B,\n      layout: Layout<sectionIDS, blockIDS>,\n      span: BoxSpan,\n      bp: (typeof BREAKPOINTS)[number]\n    ) => {\n      let dx = span.spanX;\n      let dy = span.spanY;\n\n      if (bp === \"xs\") {\n        // in xs, all boxes are full width\n        dx = 1;\n      }\n      const gridBox: GridBox = makeGridBox(getOrigin(), { x: dx, y: dy });\n      return gridBox;\n    },\n    sectionBoxTransforms: <S extends SectionIDs, B extends BlocksIDs>(\n      section: S,\n      layout: Layout<sectionIDS, blockIDS>\n    ) => {\n      return DefaultTransformationsResponsiveRows;\n    },\n    layoutTransforms: (layout: Layout<sectionIDS, blockIDS>) => {\n      return DefaultTransformationsResponsiveColumns;\n    },\n    gridNodeOptions: { ...DEFAULT_GRID_NODE_VIEW_OPTIONS },\n    gridOptions: { ...DEFAULT_GRID_OPTIONS },\n  } satisfies ThemeForLayout<sectionIDS, blockIDS>;\n\n  return theme;\n};\n\n// Working examples demonstrating the default theme usage\n\n// Example 1: Basic layout definition using valid BlockIDs and SectionIDs\nconst exampleLayout = {\n  header: {\n    block_1: { spanX: 4, spanY: 1 },\n    block_2: { spanX: 2, spanY: 1 },\n    block_3: { spanX: 3, spanY: 1 }\n  },\n  main: {\n    block_4: { spanX: 8, spanY: 6 },\n    block_5: { spanX: 4, spanY: 6 }\n  },\n  footer: {\n    block_6: { spanX: 6, spanY: 1 },\n    block_7: { spanX: 6, spanY: 1 }\n  }\n} as const satisfies Layout<'header' | 'main' | 'footer', 'block_1' | 'block_2' | 'block_3' | 'block_4' | 'block_5' | 'block_6' | 'block_7'>;\n\nconst defaultTheme = getDefaultTheme(exampleLayout);\n\n// Example 2: Using default grid node view options\nconst basicNodeOptions = resolveGridNodeViewOptions();\nconst customNodeOptions = resolveGridNodeViewOptions({\n  justifySelf: 'center',\n  zIndex: 100,\n  dataAttrs: { 'data-testid': 'grid-item' }\n});\n\nconst accessibleNodeOptions = resolveGridNodeViewOptions({\n  aria: { role: 'button', label: 'Click me' },\n  visibility: 'visible'\n});\n\n// Example 3: Using default grid options\nconst defaultGridConfig = resolveGridOptions();\nconst spacedGridConfig = resolveGridOptions({\n  gap: { value: 20, unit: 'px' },\n  justifyContent: 'center'\n});\n\nconst responsiveGridConfig = resolveGridOptions({\n  implicitColumnUnits: { value: 300, unit: 'px' },\n  autoFlow: 'column'\n});\n\n// Example 4: Theme method usage with correct block IDs\n// Resolve box spans for different breakpoints\nconst mobileNavBox = defaultTheme.resolveBoxSpan('header', 'block_1', exampleLayout, { spanX: 4, spanY: 1 }, 'xs');\nconst desktopNavBox = defaultTheme.resolveBoxSpan('header', 'block_1', exampleLayout, { spanX: 4, spanY: 1 }, 'lg');\n\n// Get section transformations\nconst headerTransforms = defaultTheme.sectionBoxTransforms('header', exampleLayout);\nconst mainTransforms = defaultTheme.sectionBoxTransforms('main', exampleLayout);\n\n// Get layout transformations\nconst layoutTransforms = defaultTheme.layoutTransforms(exampleLayout);\n\n// Example 5: Custom theme based on defaults with correct GridBox usage\nconst customTheme = getDefaultTheme(exampleLayout);\n// Override specific methods while keeping defaults for others\nconst enhancedTheme = {\n  ...customTheme,\n  resolveBoxSpan:  <S extends SectionIDs,B extends BlocksIDs>(\n    section: S,\n    boxId: B,\n    layout: typeof exampleLayout,\n    span: BoxSpan,\n    bp: (typeof BREAKPOINTS)[number]\n  ) => {\n    // Custom logic: add padding to all boxes by modifying the diagonal\n    const baseBox = customTheme.resolveBoxSpan(section, boxId, layout, span, bp);\n    return makeGridBox(\n      { x: baseBox.origin.x + 10, y: baseBox.origin.y + 10 },\n      { x: Math.max(baseBox.diagonal.x - 20, 50), y: Math.max(baseBox.diagonal.y - 20, 30) }\n    );\n  },\n  gridOptions: resolveGridOptions({\n    gap: { value: 16, unit: 'px' },\n    justifyContent: 'center'\n  })\n};\n\n// Example 6: Using transformation constants directly\nconst customRowTransforms = {\n  ...DefaultTransformationsResponsiveRows,\n  xs: [{ stackVertically: { gap: 10 } }],\n  md: [{ stackHorizontally: { gap: 20 } }]\n} as const satisfies BoxTransformations<NodeID>;\n\nconst customColumnTransforms = {\n  ...DefaultTransformationsResponsiveColumns,\n  xs: [{ stackVertically: { gap: 15 } }],\n  lg: [{ stackVertically: { gap: 30 } }]\n} as const satisfies BoxTransformations<NodeID>;\n","\n/**\n * @fileoverview Layout to transformation converter for CSS Grid layout system.\n * Transforms abstract layout definitions into concrete grid transformations with positioning data.\n * Handles the conversion from layout specifications to executable grid configurations across breakpoints.\n * @module LayoutToTx\n */\n\nimport { GridBox } from '../box/gridBoxTypes';\n \nimport {\n \n  BPSGridBoxes,\n  GridBoxesAndTx,\n  Layout,\n  LayoutWithTx,\n \n} from '../boxLayout/boxLayoutTypes';\nimport { BREAKPOINTS } from '../breakpoints';\nimport { DiagnosticEntry, GRID_ERROR_CODE, makeError } from '../gridErrorShape';\nimport { getDefaultTheme } from '../layoutTheme/defaultLayoutTheme';\nimport { ThemeForLayout } from '../layoutTheme/layoutThemeTypes';\nimport { BlocksIDs , SectionIDs} from '../templates';\n\n \n\n/**\n * Extracts section keys that are actually present in the layout at runtime.\n * Provides both runtime and type safety by filtering based on value existence rather than just key presence.\n * This prevents processing of undefined or null sections that might exist as keys but have no content.\n * \n * Key behaviors:\n * - Filters by VALUE existence, not just key presence\n * - Runtime-safe boundary checking prevents null reference errors\n * - Type-safe return maintains compile-time guarantees\n * - Handles dynamic layout structures where sections may be conditionally defined\n * \n * @template L - The layout type to extract section keys from\n * @param layout - The layout object to extract present section keys from\n * @returns Array of section IDs that have actual content (not null/undefined)\n * \n * @example\n * ```typescript\n * const layout = {\n *   header: { block_1: { spanX: 2, spanY: 1 } },\n *   main: null, // This section will be filtered out\n *   footer: { block_2: { spanX: 1, spanY: 1 } }\n * };\n * \n * const presentSections = layoutSectionKeysPresent(layout);\n * // Returns: ['header', 'footer'] (main is excluded)\n * ```\n */\nexport function layoutSectionKeysPresent<sectionIDS extends SectionIDs, blockIDS extends BlocksIDs>(layout: Layout<sectionIDS, blockIDS>): Array<sectionIDS> {\n  return Object.keys(layout).filter((k) => (layout as any)[k] != null) as Array<sectionIDS>;\n}\n\n/**\n * Runtime type guard to validate that a string matches the BlocksIDs pattern.\n * Ensures that only properly formatted block identifiers are processed, preventing\n * issues with malformed or unexpected keys that might exist in dynamic layouts.\n * \n * Block IDs must follow the pattern 'block_' followed by additional characters.\n * This function acts as a runtime safety net for type checking that can't be\n * enforced at compile time when dealing with dynamic object keys.\n * \n * @param k - The string to validate as a BlocksID\n * @returns True if the string is a valid BlocksID, false otherwise\n * \n * @example\n * ```typescript\n * isBlocksID('block_1'); // true\n * isBlocksID('block_header'); // true\n * isBlocksID('section_1'); // false\n * isBlocksID('invalid'); // false\n * \n * // Usage in filtering\n * const keys = Object.keys(someObject);\n * const blockKeys = keys.filter(isBlocksID);\n * ```\n */\nexport function isBlocksID(k: string): k is BlocksIDs {\n  return k.startsWith('block_');\n}\n\n/**\n * Extracts block keys that are actually present within a specific section of a layout.\n * Provides type-safe access to blocks within a section, ensuring that the returned\n * block IDs are valid for the specific layout and section combination.\n * \n * Key features:\n * - Layout-bound generics tie L and S to actual runtime arguments\n * - No free-floating generic parameters that could cause type mismatches\n * - Runtime filtering ensures only valid block IDs are returned\n * - Type safety guarantees that returned IDs exist in the specified section\n * \n * This function is essential for the transformation pipeline as it ensures\n * that only blocks that actually exist in the layout are processed for grid conversion.\n * \n * @template L - The layout type (inferred from the layout parameter)\n * @template Sec - The section type (inferred from the section parameter, constrained to valid sections in L)\n * @param layout - The complete layout object\n * @param section - The section key to extract block keys from\n * @returns Array of block IDs that exist within the specified section\n * \n * @example\n * ```typescript\n * const layout = {\n *   header: { block_1: { spanX: 2, spanY: 1 }, block_2: { spanX: 1, spanY: 1 } },\n *   main: { block_3: { spanX: 4, spanY: 2 } }\n * };\n * \n * const headerBlocks = layoutBlockKeysPresent(layout, 'header');\n * // Returns: ['block_1', 'block_2']\n * \n * const mainBlocks = layoutBlockKeysPresent(layout, 'main');\n * // Returns: ['block_3']\n * ```\n */\nexport function layoutBlockKeysPresent<sectionIDS extends SectionIDs, blockIDS extends BlocksIDs>(\n  layout: Layout<sectionIDS, blockIDS>,\n  section: sectionIDS,\n): Array<blockIDS> {\n  const blocks = layout[section];\n  if (!blocks) return [];\n\n  return Object.keys(blocks).filter(isBlocksID) as Array<blockIDS>;\n}\n\n/**\n * Converts an abstract layout definition into a concrete layout with transformations and grid boxes.\n * This is the main transformation function that processes layout specifications and generates\n * executable grid configurations for all breakpoints using the provided or default theme.\n * \n * Processing pipeline:\n * 1. Applies default theme if none provided\n * 2. Extracts present sections from the layout\n * 3. For each section, extracts present blocks\n * 4. For each block at each breakpoint, resolves box spans to concrete GridBox coordinates\n * 5. Applies section and layout-level transformations\n * 6. Collects diagnostic information for any issues encountered\n * \n * Error handling:\n * - Missing sections are logged and skipped\n * - Missing box spans are logged and skipped\n * - Diagnostic entries provide detailed error information for debugging\n * - Process continues despite individual failures to maximize valid output\n * \n * @template L - The layout type being processed\n * @param layout - The abstract layout definition to convert\n * @param diagnostic - Array to collect diagnostic information and errors\n * @param theme - Optional theme for customizing the conversion process (uses default if not provided)\n * @returns Complete layout with transformations and positioned grid boxes for all breakpoints\n * \n * @example\n * ```typescript\n * const layout = {\n *   header: { block_1: { spanX: 4, spanY: 1 }, block_2: { spanX: 2, spanY: 1 } },\n *   main: { block_3: { spanX: 6, spanY: 4 } }\n * };\n * \n * const diagnostics: DiagnosticEntry[] = [];\n * const layoutWithTx = layoutToTx(layout, diagnostics);\n * \n * // Result contains:\n * // - layoutWithTx.sections[sectionId].gridBoxes[breakpoint][blockId] = GridBox\n * // - layoutWithTx.sections[sectionId].transformations = section-level transforms\n * // - layoutWithTx.transformations = layout-level transforms\n * \n * // Check for any issues\n * if (diagnostics.length > 0) {\n *   console.log('Processing issues:', diagnostics);\n * }\n * ```\n */\nexport function layoutToTx<sectionIDS extends SectionIDs, blockIDS extends BlocksIDs>(\n  layout: Layout<sectionIDS, blockIDS>,\n  diagnostic: DiagnosticEntry[],\n  theme?: ThemeForLayout<sectionIDS, blockIDS>,\n): LayoutWithTx<sectionIDS, blockIDS> {\n  //\n  if (!theme) {\n    theme = getDefaultTheme(layout);\n  }\n\n  let layoutWithTx = {} as LayoutWithTx<sectionIDS, blockIDS>;\n\n  layoutWithTx.sections = {} as Record<sectionIDS, GridBoxesAndTx<blockIDS>>;\n  layoutWithTx.transformations = theme.layoutTransforms(layout);\n\n  const sectionsIDS = layoutSectionKeysPresent(layout);\n\n  for (const sectionID of sectionsIDS) {\n    //\n    const section = layout[sectionID];\n\n    if (!section) {\n      diagnostic.push(\n        makeError(\n          'layoutToTx',\n          GRID_ERROR_CODE.NO_SECTION_ID,\n          `Section ${sectionID} has no boxes defined in layout. Skipping layoutToTx for this section.`,\n        ),\n      );\n\n      continue;\n    }\n\n    layoutWithTx.sections[sectionID] = {} as GridBoxesAndTx<blockIDS>;\n\n    layoutWithTx.sections[sectionID].gridBoxes = {} as BPSGridBoxes<blockIDS>;\n    layoutWithTx.sections[sectionID].transformations = theme.sectionBoxTransforms(\n      sectionID,\n      layout,\n    );\n\n    BREAKPOINTS.forEach((bp) => {\n      //\n      layoutWithTx.sections[sectionID].gridBoxes[bp] = {} as Partial<Record<blockIDS, GridBox>>;\n\n      for (const boxID of layoutBlockKeysPresent(layout, sectionID)) {\n        const boxSpan = section[boxID];\n\n        if (!boxSpan) {\n          diagnostic.push(\n            makeError(\n              'layoutToTx',\n              GRID_ERROR_CODE.BOX_SPAN_MISSING,\n              `Box ${boxID} in section ${sectionID} has no box span defined in layout. Skipping layoutToTx for this box.`,\n            ),\n          );\n          continue;\n        }\n\n        layoutWithTx.sections[sectionID].gridBoxes[bp][boxID] = theme.resolveBoxSpan(\n          sectionID,\n          boxID,\n          layout,\n          boxSpan,\n          bp,\n        );\n      }\n    });\n  }\n\n  return layoutWithTx;\n}\n\n// Examples extracted from documentation comments above\n\n// Example 1: layoutSectionKeysPresent usage\n// const layoutExample1 = {\n//   header: { block_1: { spanX: 2, spanY: 1 } },\n//   main: null, // This section will be filtered out\n//   footer: { block_2: { spanX: 1, spanY: 1 } }\n// } as const satisfies Layout;\n\n// const presentSections = layoutSectionKeysPresent(layoutExample1);\n// Returns: ['header', 'footer'] (main is excluded)\n\n// Example 2: isBlocksID usage\nconst isValidBlock1 = isBlocksID('block_1'); // true\nconst isValidBlock2 = isBlocksID('block_header'); // true\nconst isValidBlock3 = isBlocksID('section_1'); // false\nconst isValidBlock4 = isBlocksID('invalid'); // false\n\n// Usage in filtering\nconst someObject = { block_1: 'valid', section_1: 'invalid', block_2: 'valid', other: 'invalid' };\nconst keys = Object.keys(someObject);\nconst blockKeys = keys.filter(isBlocksID);\n\n// Example 3: layoutBlockKeysPresent usage\nconst layoutExample3 = {\n  header: { block_1: { spanX: 2, spanY: 1 }, block_2: { spanX: 1, spanY: 1 } },\n  main: { block_3: { spanX: 4, spanY: 2 } }\n} as const satisfies Layout<'header' | 'main', 'block_1' | 'block_2' | 'block_3'>;\n\nconst headerBlocks = layoutBlockKeysPresent(layoutExample3, 'header');\n// Returns: ['block_1', 'block_2']\n\nconst mainBlocks = layoutBlockKeysPresent(layoutExample3, 'main');\n// Returns: ['block_3']\n\n// Example 4: layoutToTx usage\nconst layoutExample4 = {\n  header: { block_1: { spanX: 4, spanY: 1 }, block_2: { spanX: 2, spanY: 1 } },\n  main: { block_3: { spanX: 6, spanY: 4 } }\n} as const satisfies Layout<'header' | 'main', 'block_1' | 'block_2' | 'block_3'>;\n\nconst diagnostics: DiagnosticEntry[] = [];\nconst layoutWithTx = layoutToTx(layoutExample4, diagnostics);\n\n// Result contains:\n// - layoutWithTx.sections[sectionId].gridBoxes[breakpoint][blockId] = GridBox\n// - layoutWithTx.sections[sectionId].transformations = section-level transforms\n// - layoutWithTx.transformations = layout-level transforms\n\n// Check for any issues\nif (diagnostics.length > 0) {\n  console.log('Processing issues:', diagnostics);\n}\n","/**\n * @fileoverview Layout templates catalog for CSS Grid layout system.\n * Provides pre-defined layout configurations organized by categories and use cases.\n * @module LayoutsCatalog\n */\n\nimport { Layout } from \"../boxLayout/boxLayoutTypes\";\n\n/**\n * Union type of all available catalog categories.\n * Extracts the top-level keys from the layouts catalog.\n */\nexport type CatalogEntries = keyof typeof layoutsCatalog;\n\n/**\n * Union type of layout names within a specific catalog category.\n * Extracts the layout keys for a given category.\n * \n * @template K - The catalog category to get layout entries for\n */\nexport type LayoutsEntries<K extends CatalogEntries> = keyof (typeof layoutsCatalog)[K];\n\n/**\n * Type of the complete layouts catalog.\n * Provides type safety for the entire catalog structure.\n */\nexport type LayoutsCatalog = typeof layoutsCatalog;\n\n/**\n * Retrieves all available catalog category keys.\n * Returns an array of category names for iterating through the catalog.\n * \n * @returns Array of catalog category names\n * \n * @example\n * ```typescript\n * const categories = getCatalogCategoryKeys();\n * // Result: ['primary20', 'secondary']\n * \n * categories.forEach(category => {\n *   console.log(`Available category: ${category}`);\n * });\n * ```\n */\nexport const getCatalogCategoryKeys = (): CatalogEntries[] =>\n  Object.keys(layoutsCatalog) as CatalogEntries[];\n\n/**\n * Retrieves all layout keys for a specific catalog category.\n * Returns an array of layout names within the specified category.\n * \n * @template K - The catalog category type\n * @param catalogKey - The category to get layouts for\n * @returns Array of layout names in the specified category\n * \n * @example\n * ```typescript\n * const primary20Layouts = getLayoutKeysForCategory('primary20');\n * // Result: ['page_band', 'page_headerContentFooter', 'page_twoCol_10_10', ...]\n * \n * const secondaryLayouts = getLayoutKeysForCategory('secondary');\n * // Result: ['singleCell', 'twoCells', 'sideBarAndContent', ...]\n * ```\n */\nexport const getLayoutKeysForCategory = <K extends CatalogEntries>(\n  catalogKey: K,\n): LayoutsEntries<K>[] =>\n  Object.keys(layoutsCatalog[catalogKey]) as LayoutsEntries<K>[];\n\n/**\n * Retrieves a specific layout from the catalog with type safety.\n * Returns a deep clone of the layout to prevent mutations of the original template.\n * \n * @template K - The catalog category type\n * @template L - The layout name type within the category\n * @param catalogKey - The category containing the desired layout\n * @param layoutKey - The name of the layout to retrieve\n * @returns A deep clone of the requested layout\n * \n * @example\n * ```typescript\n * // Get a two-column layout from primary20 category\n * const twoColLayout = getLayoutFromCatalog('primary20', 'page_twoCol_10_10');\n * \n * // Get a simple layout from secondary category\n * const singleLayout = getLayoutFromCatalog('secondary', 'singleCell');\n * \n * // Use in layout configuration\n * const myLayout = getLayoutFromCatalog('primary20', 'page_headerContentFooter');\n * // Safe to modify myLayout without affecting the catalog\n * ```\n */\nexport const getLayoutFromCatalog = <\n  K extends CatalogEntries,\n  L extends LayoutsEntries<K>,\n>(\n  catalogKey: K,\n  layoutKey: L,\n): LayoutsCatalog[K][L] => {\n  const layout = layoutsCatalog[catalogKey][layoutKey] as LayoutsCatalog[K][L];\n  return structuredClone(layout) as LayoutsCatalog[K][L];\n};\n\n\n/**\n * Comprehensive catalog of pre-defined layout templates.\n * Organized into categories based on grid complexity and use cases.\n * \n * Categories:\n * - `primary20`: Layouts designed for 20-column grids, suitable for desktop/wide screens\n * - `secondary`: Simpler layouts with flexible column counts, suitable for smaller screens\n * \n * Available layouts:\n * \n * **Primary20 Category (20-column grid layouts):**\n * - `page_band`: Single full-width band layout\n * - `page_headerContentFooter`: Classic header-content-footer structure\n * - `page_twoCol_10_10`: Equal two-column layout (50/50 split)\n * - `page_twoCol_5_15`: Narrow sidebar with wide content (25/75 split)\n * - `page_twoCol_15_5`: Wide content with narrow sidebar (75/25 split)\n * - `page_twoCol_4_16`: Very narrow sidebar layout (20/80 split)\n * - `page_twoCol_16_4`: Maximum content with minimal sidebar (80/20 split)\n * - `page_twoCol_8_12`: Medium sidebar with main content (40/60 split)\n * - `page_twoCol_12_8`: Main content with medium sidebar (60/40 split)\n * - `page_threeCol_5_10_5`: Balanced three-column with central focus\n * - `page_docs_3_14_3`: Documentation style with narrow sidebars\n * - `page_docs_4_12_4`: Wider documentation layout\n * - `page_fourCol_5_5_5_5`: Equal four-column grid\n * - `page_dashboard_kpis_then_content`: Dashboard with KPI row and content section\n * \n * **Secondary Category (Flexible responsive layouts):**\n * - `singleCell`: Minimal single block layout\n * - `twoCells`: Simple two equal blocks\n * - `sideBarAndContent`: Sidebar with wider content area\n * - `footerHeader5Columns`: Header/footer with 5-column content grid\n * - `footerHeader3Columns`: Header/footer with 3-column content\n * - `header2colFooter`: Header with 2-column content and footer\n * - `header3colFooter`: Header with 3-column content and footer\n * - `twoRowsOf3`: Grid with two rows of 3 columns each\n * - `twoRowsOf6`: Dense grid with two rows of 6 columns each\n * - `mixedDensityShowcase`: Progressive grid with increasing column density\n * - `featuredRow4`: 4 blocks with one double-wide featured block\n * - `featuredRow5`: 5 blocks with one double-wide featured block\n * - `featuredRow5Big`: 5 blocks with one triple-wide featured block\n * \n * Each layout is a complete Layout configuration with sections, blocks, and span definitions.\n * All layouts use the spanX/spanY system to define block dimensions within their grid context.\n */\nconst layoutsCatalog = {\n  /**\n   * Primary20 category: Layout templates designed for 20-column grids.\n   * These layouts are optimized for desktop and wide-screen displays.\n   * All spanX values are calculated based on a 20-column grid system.\n   */\n  primary20: {\n    /**\n     * Single full-width band layout.\n     * Contains one row with a single block spanning the full 20 columns.\n     * Perfect for hero sections, banners, or simple single-content pages.\n     */\n    page_band: {\n      row_1: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"row_1\", \"block_1\">,\n\n    /**\n     * Classic header-content-footer layout.\n     * Three-section vertical layout with full-width sections.\n     * Standard pattern for most web pages and applications.\n     */\n    page_headerContentFooter: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      content: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"content\" | \"footer\", \"block_1\">,\n\n    /**\n     * Equal two-column layout (10/10 split).\n     * Header and footer span full width, main content split evenly.\n     * Ideal for balanced content presentation or comparison layouts.\n     */\n    page_twoCol_10_10: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 10, spanY: 1 },\n        block_2: { spanX: 10, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Narrow sidebar with wide content (5/15 split).\n     * Left sidebar takes 25% width, content area takes 75%.\n     * Common for navigation + content layouts.\n     */\n    page_twoCol_5_15: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 5, spanY: 1 },\n        block_2: { spanX: 15, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Wide content with narrow sidebar (15/5 split).\n     * Content area takes 75% width, right sidebar takes 25%.\n     * Useful for primary content with secondary information.\n     */\n    page_twoCol_15_5: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 15, spanY: 1 },\n        block_2: { spanX: 5, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Very narrow sidebar layout (4/16 split).\n     * Minimal sidebar for icons/navigation, maximum content space.\n     * Suitable for app interfaces with icon-based navigation.\n     */\n    page_twoCol_4_16: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 4, spanY: 1 },\n        block_2: { spanX: 16, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Wide content with very narrow sidebar (16/4 split).\n     * Maximum content space with minimal sidebar.\n     * Mirror of the 4/16 layout with sidebar on the right.\n     */\n    page_twoCol_16_4: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 16, spanY: 1 },\n        block_2: { spanX: 4, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Medium sidebar with main content (8/12 split).\n     * Sidebar takes 40% width, content takes 60%.\n     * Good balance for secondary navigation and content.\n     */\n    page_twoCol_8_12: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 8, spanY: 1 },\n        block_2: { spanX: 12, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Main content with medium sidebar (12/8 split).\n     * Content takes 60% width, sidebar takes 40%.\n     * Mirror of the 8/12 layout with sidebar on the right.\n     */\n    page_twoCol_12_8: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 12, spanY: 1 },\n        block_2: { spanX: 8, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Balanced three-column layout (5/10/5 split).\n     * Equal sidebars with wider central content area.\n     * Classic layout for content with two complementary sidebars.\n     */\n    page_threeCol_5_10_5: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 5, spanY: 1 },\n        block_2: { spanX: 10, spanY: 1 },\n        block_3: { spanX: 5, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\" | \"block_3\">,\n\n    /**\n     * Documentation-style layout (3/14/3 split).\n     * Narrow sidebars with maximum central content space.\n     * Optimized for reading experiences with minimal distractions.\n     */\n    page_docs_3_14_3: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 3, spanY: 1 },\n        block_2: { spanX: 14, spanY: 1 },\n        block_3: { spanX: 3, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\" | \"block_3\">,\n\n    /**\n     * Wider documentation layout (4/12/4 split).\n     * Slightly wider sidebars for more navigation or content options.\n     * Balance between content focus and sidebar functionality.\n     */\n    page_docs_4_12_4: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 4, spanY: 1 },\n        block_2: { spanX: 12, spanY: 1 },\n        block_3: { spanX: 4, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\" | \"block_3\">,\n\n    /**\n     * Equal four-column layout (5/5/5/5 split).\n     * Perfect symmetry with four equal content areas.\n     * Ideal for feature showcases, product grids, or dashboard cards.\n     */\n    page_fourCol_5_5_5_5: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 5, spanY: 1 },\n        block_2: { spanX: 5, spanY: 1 },\n        block_3: { spanX: 5, spanY: 1 },\n        block_4: { spanX: 5, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"footer\", \"block_1\" | \"block_2\" | \"block_3\" | \"block_4\">,\n\n    /**\n     * Dashboard layout with KPI row and content section.\n     * Top row for key performance indicators (4 equal blocks).\n     * Bottom section with sidebar and main content area.\n     * Perfect for admin dashboards and analytics interfaces.\n     */\n    page_dashboard_kpis_then_content: {\n      header: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n      main: {\n        block_1: { spanX: 5, spanY: 1 },\n        block_2: { spanX: 5, spanY: 1 },\n        block_3: { spanX: 5, spanY: 1 },\n        block_4: { spanX: 5, spanY: 1 },\n      },\n      content: {\n        block_1: { spanX: 8, spanY: 1 },\n        block_2: { spanX: 12, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 20, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"main\" | \"content\" | \"footer\", \"block_1\" | \"block_2\" | \"block_3\" | \"block_4\">,\n  },\n\n  /**\n   * Secondary category: Flexible layouts with adaptive column counts.\n   * These layouts are designed to be more responsive and work well on various screen sizes.\n   * Column counts are minimal and can be adapted to different grid systems.\n   */\n  secondary: {\n    /**\n     * Minimal single cell layout.\n     * Contains one block in one row - simplest possible layout.\n     * Perfect for landing pages, simple forms, or focused content.\n     */\n    singleCell: {\n      row_1: {\n        block_1: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"row_1\", \"block_1\">,\n\n    /**\n     * Simple two-cell layout.\n     * Two blocks side by side in equal proportions.\n     * Basic building block for comparison layouts.\n     */\n    twoCells: {\n      row_1: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"row_1\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Sidebar with content layout.\n     * Small sidebar (1 unit) with wider content area (5 units).\n     * Responsive alternative to fixed-width sidebar layouts.\n     */\n    sideBarAndContent: {\n      row_1: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 5, spanY: 1 },\n      },\n    } satisfies Layout<\"row_1\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Header-footer layout with 5-column content.\n     * Header and footer with sidebar/content split.\n     * Content area has 5 equal columns for flexible organization.\n     */\n    footerHeader5Columns: {\n      header: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 5, spanY: 1 },\n      },\n      content: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n        block_4: { spanX: 1, spanY: 1 },\n        block_5: { spanX: 1, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 5, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"content\" | \"footer\", \"block_1\" | \"block_2\" | \"block_3\" | \"block_4\" | \"block_5\">,\n\n    /**\n     * Simple header-content-footer with 3 columns.\n     * Equal-width content columns for balanced presentation.\n     * Clean and symmetric layout for basic content organization.\n     */\n    footerHeader3Columns: {\n      header: {\n        block_1: { spanX: 3, spanY: 1 },\n      },\n      content: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 3, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"content\" | \"footer\", \"block_1\" | \"block_2\" | \"block_3\">,\n\n    /**\n     * Header with 2-column content and footer.\n     * Minimal header/footer with two-column content area.\n     * Perfect for simple comparison or side-by-side content.\n     */\n    header2colFooter: {\n      header: {\n        block_1: { spanX: 1, spanY: 1 },\n      },\n      content: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"content\" | \"footer\", \"block_1\" | \"block_2\">,\n\n    /**\n     * Header with 3-column content and footer.\n     * Similar to header2colFooter but with three content columns.\n     * Good for feature showcases or service presentations.\n     */\n    header3colFooter: {\n      header: {\n        block_1: { spanX: 1, spanY: 1 },\n      },\n      content: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | \"content\" | \"footer\", \"block_1\" | \"block_2\" | \"block_3\">,\n\n    /**\n     * Two rows with 3 columns each.\n     * Grid of 6 equal blocks arranged in 2 rows.\n     * Perfect for feature grids, team members, or product showcases.\n     */\n    twoRowsOf3: {\n      row_1: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n      },\n      row_2: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"row_1\" | \"row_2\", \"block_1\" | \"block_2\" | \"block_3\">,\n\n    /**\n     * Two rows with 6 columns each.\n     * Dense grid of 12 equal blocks for extensive content.\n     * Suitable for galleries, portfolios, or comprehensive listings.\n     */\n    twoRowsOf6: {\n      row_1: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n        block_4: { spanX: 1, spanY: 1 },\n        block_5: { spanX: 1, spanY: 1 },\n        block_6: { spanX: 1, spanY: 1 },\n      },\n      row_2: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n        block_4: { spanX: 1, spanY: 1 },\n        block_5: { spanX: 1, spanY: 1 },\n        block_6: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"row_1\" | \"row_2\", \"block_1\" | \"block_2\" | \"block_3\" | \"block_4\" | \"block_5\" | \"block_6\">,\n\n    /**\n     * Mixed density showcase layout.\n     * Progressive grid that starts simple and becomes more complex.\n     * Demonstrates increasing content density from 1 to 5 columns per row.\n     * Perfect for showcasing scalability or progressive disclosure.\n     */\n    mixedDensityShowcase: {\n      header: {\n        block_1: { spanX: 1, spanY: 1 },\n      },\n      row_1: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n      },\n      row_2: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n      },\n      row_3: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n        block_4: { spanX: 1, spanY: 1 },\n      },\n      row_4: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n        block_4: { spanX: 1, spanY: 1 },\n        block_5: { spanX: 1, spanY: 1 },\n      },\n      footer: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 1, spanY: 1 },\n        block_3: { spanX: 1, spanY: 1 },\n        block_4: { spanX: 1, spanY: 1 },\n        block_5: { spanX: 1, spanY: 1 },\n        block_6: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"header\" | 'row_1'|'row_2'|'row_3'|'row_4'|\"footer\", \"block_1\" | \"block_2\" | \"block_3\" | \"block_4\" | \"block_5\" | \"block_6\">,\n\n    /**\n     * Featured row with 4 blocks (one double-wide).\n     * Second block spans 2 columns for emphasis.\n     * Great for highlighting featured content alongside regular items.\n     */\n    featuredRow4: {\n      row_1: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 2, spanY: 1 }, // featured double-wide\n        block_3: { spanX: 1, spanY: 1 },\n        block_4: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"row_1\", \"block_1\" | \"block_2\" | \"block_3\" | \"block_4\">,\n\n    /**\n     * Featured row with 5 blocks (one double-wide).\n     * Similar to featuredRow4 but with additional content block.\n     * Balances featured content with more supporting elements.\n     */\n    featuredRow5: {\n      row_1: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 2, spanY: 1 }, // featured double-wide\n        block_3: { spanX: 1, spanY: 1 },\n        block_4: { spanX: 1, spanY: 1 },\n        block_5: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"row_1\", \"block_1\" | \"block_2\" | \"block_3\" | \"block_4\" | \"block_5\">,\n\n    /**\n     * Featured row with prominent triple-wide block.\n     * Second block spans 3 columns for maximum emphasis.\n     * Perfect for hero content with minimal supporting elements.\n     */\n    featuredRow5Big: {\n      row_1: {\n        block_1: { spanX: 1, spanY: 1 },\n        block_2: { spanX: 3, spanY: 1 }, // featured triple-wide\n        block_3: { spanX: 1, spanY: 1 },\n        block_4: { spanX: 1, spanY: 1 },\n        block_5: { spanX: 1, spanY: 1 },\n      },\n    } satisfies Layout<\"row_1\", \"block_1\" | \"block_2\" | \"block_3\" | \"block_4\" | \"block_5\">,\n  },\n};\n","\n/**\n * @fileoverview Utility functions for type-safe object operations.\n * Provides type-safe alternatives to common JavaScript object operations.\n * @module Utils\n */\n\n/**\n * Returns the keys of an object with proper type safety.\n * Provides a type-safe alternative to Object.keys() that preserves key types.\n * \n * @template T - The object type\n * @param obj - The object to extract keys from\n * @returns Array of keys with proper typing\n * \n * @example\n * ```typescript\n * const config = {\n *   width: 100,\n *   height: 200,\n *   visible: true\n * } as const;\n * \n * // Type-safe keys\n * const keys = typedKeys(config); // Array<\"width\" | \"height\" | \"visible\">\n * \n * // Compare with Object.keys() which returns string[]\n * const unsafeKeys = Object.keys(config); // string[]\n * \n * // Usage in loops\n * typedKeys(config).forEach(key => {\n *   console.log(config[key]); // TypeScript knows the correct type\n * });\n * ```\n */\n export function typedKeys<T extends object>(obj: T): Array<keyof T> {\n  return Object.keys(obj) as Array<keyof T>;\n}"],"mappings":"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","names":["a","b","coord","a","b","point","a","b","coord","origin","to","boxes","diagnostics","from","displacement","diagnostics","result","diagnostics","transformations","minCoordinate","coord","layoutSectionKeys","diagnostics","diagnostics","transformations","layoutWithTx","diagnostics","a","b","layout","layoutWithTx","keys","diagnostics"]}